%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{KiMoPack}
\date{Mar 28, 2022}
\release{6.5.1}
\author{Jens Uhlig}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{Introduction:introduction}}\label{\detokenize{Introduction::doc}}
KiMoPack is a project for the handling of spectral data measure at
multiple time\sphinxhyphen{}points. The current design is optimised for the use with
optical transient absorption data, but it has been successfully adapted
for the use with transient x\sphinxhyphen{}ray emission and spectro\sphinxhyphen{}electro chemistry
data.

It focuses on the main tasks an experimentator has
Loading and shaping of experiments, plotting of experiments, comparing of experiments,
analysing experiments with fast and/or advanced fitting routines and saving/exporting/presenting
the results.

The software can be used on several different levels. The simplest level packs everything
into an object “TA” that contains all the parameters that are typically set.
These objects also contain the typical functions that are used in an analysis.
See {\hyperref[\detokenize{Main_tasks:main-tasks-overview}]{\sphinxcrossref{\DUrole{std,std-ref}{Main Tasks overview}}}} for an overview of these functions.
All active functions have a capital letter in the beginning.

At the lower levels a series of convenience functions for the efficient plotting of
one or two dimensional data is provided. These are typical in the main module

For typical use a series of juypter notebooks are provided that guide
through the a number of different use scenarios, and are suggesting the
parameter that are typically set.
\begin{description}
\item[{In addition a series of tutorial notebooks are provided that guide the user through the different functions. These Tutorials can either be downloaded or executed on a “mybinder” server via this badge.}] \leavevmode
\sphinxhref{https://mybinder.org/v2/gh/erdzeichen/KiMoPack/HEAD}{\sphinxincludegraphics{{d:\Dropbox\coding\github\KiMoPack\docs\build\doctrees\images\564aeb29a2e0a759592d48f87044710bf7928b8a\badge_logo}.svg}}

\end{description}


\chapter{Installation}
\label{\detokenize{Installation:installation}}\label{\detokenize{Installation::doc}}
The basis of the program is a module called “plot\_func.py” that contains all the necessary functions and classes.
We provide a series of jupyter based work flow packages that guide the user through a series of typical tasks
during the analysis of optical transient absorption data and that we strongly recommend.
The files can be downloaded from the github directory \sphinxurl{https://github.com/erdzeichen/KiMoPack} and manually installed (added to the path).
Alternatively we recommend the usage of the usual python install commands “pip” or if the distribution is using the Anaconda
package manager, The conda type installation. For both please open a command line (e.g. using “cmd” in windows) and execute the following commands.
The Jupyter notebooks are copied during the install process. The notebooks can also be downloaded from the github server \sphinxurl{https://github.com/erdzeichen/KiMoPack}.

Install and update using “pip”:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} pip install KiMoPack
\end{sphinxVerbatim}

Install and update using “conda” from the channel erdzeichen:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} conda install \PYGZhy{}c erdzeichen kimopack
\end{sphinxVerbatim}


\section{Links}
\label{\detokenize{Installation:links}}\begin{itemize}
\item {} 
Documentation: \sphinxurl{https://kimopack.readthedocs.io/}

\item {} 
PyPI Releases: \sphinxurl{https://pypi.org/project/KiMoPack/}

\item {} 
Source Code: \sphinxurl{https://github.com/erdzeichen/KiMoPack}

\item {} 
Issue Tracker: \sphinxurl{https://github.com/erdzeichen/KiMoPack/issues}

\item {} 
Website: \sphinxurl{https://www.chemphys.lu.se/research/projects/kimopack/}

\item {} 
Zenodo: \sphinxurl{https://doi.org/10.5281/zenodo.5720587}

\end{itemize}


\chapter{Main Tasks overview}
\label{\detokenize{Main_tasks:main-tasks-overview}}\label{\detokenize{Main_tasks::doc}}
This menu is a shortcut to the main function and tasks that are performed during an analysis.
In general one opens one or multiple data Files and after defining a number of shaping parameter, that
e.g. set the axis limits or correct the arrival time of different wavelength,  plots various graphs.
Different measurements or Fits can be compared and the results saved in various forms.
\begin{itemize}
\item {} 
{\hyperref[\detokenize{Opening:opening-of-data}]{\sphinxcrossref{\DUrole{std,std-ref}{Opening of data}}}}
\begin{itemize}
\item {} 
Open single file:                     {\hyperref[\detokenize{plot_func:plot_func.TA.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.TA()}}}}}

\item {} 
Open many files:                              {\hyperref[\detokenize{plot_func:plot_func.GUI_open}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.GUI\_open()}}}}}

\item {} 
Combine many scans:                   {\hyperref[\detokenize{plot_func:plot_func.Summarize_scans}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.Summarize\_scans()}}}}}

\end{itemize}

\item {} 
{\hyperref[\detokenize{Shaping:shaping-of-data}]{\sphinxcrossref{\DUrole{std,std-ref}{Shaping of Data}}}}
\begin{itemize}
\item {} 
Background correction:                        {\hyperref[\detokenize{plot_func:plot_func.TA.Background}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Background()}}}}}

\item {} 
Filter bad data:                              {\hyperref[\detokenize{plot_func:plot_func.TA.Filter_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Filter\_data()}}}}}

\item {} 
Correct arrival time (Chirp)  {\hyperref[\detokenize{plot_func:plot_func.TA.Cor_Chirp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Cor\_Chirp()}}}}}

\item {} 
{\hyperref[\detokenize{Shaping:data-shaping-settings-that-affect-the-fits}]{\sphinxcrossref{\DUrole{std,std-ref}{Data shaping settings that affect the fits}}}}

\item {} 
{\hyperref[\detokenize{Plotting:plot-shaping-options-without-influence-on-the-fitting}]{\sphinxcrossref{\DUrole{std,std-ref}{Plot shaping options without influence on the fitting}}}}

\end{itemize}

\item {} 
{\hyperref[\detokenize{Plotting:plotting-functions}]{\sphinxcrossref{\DUrole{std,std-ref}{Plotting functions}}}}
\begin{itemize}
\item {} 
Plotting non Fitted data:     {\hyperref[\detokenize{plot_func:plot_func.TA.Plot_RAW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Plot\_RAW()}}}}}

\item {} 
Plotting Fitted data:         {\hyperref[\detokenize{plot_func:plot_func.TA.Plot_fit_output}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Plot\_fit\_output()}}}}}

\item {} 
Adjust fonts in plots:                {\hyperref[\detokenize{plot_func:plot_func.changefonts}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.changefonts()}}}}}

\end{itemize}

\item {} 
{\hyperref[\detokenize{Fitting:fitting-parameter-optimization-and-error-estimation}]{\sphinxcrossref{\DUrole{std,std-ref}{Fitting, Parameter optimization and Error estimation}}}}
\begin{itemize}
\item {} 
Fitting data:                         {\hyperref[\detokenize{plot_func:plot_func.TA.Fit_Global}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Fit\_Global()}}}}}

\end{itemize}

\item {} 
{\hyperref[\detokenize{Comparing:comparative-plotting}]{\sphinxcrossref{\DUrole{std,std-ref}{Comparative plotting}}}}
\begin{itemize}
\item {} 
Compare spectra:                              {\hyperref[\detokenize{plot_func:plot_func.TA.Compare_at_time}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Compare\_at\_time()}}}}}

\item {} 
Compare kinetics:                             {\hyperref[\detokenize{plot_func:plot_func.TA.Compare_at_wave}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Compare\_at\_wave()}}}}}

\item {} 
Compare calculated spectra (SAS or DAS):      {\hyperref[\detokenize{plot_func:plot_func.TA.Compare_DAC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Compare\_DAC()}}}}}

\end{itemize}

\item {} 
{\hyperref[\detokenize{Saving:data-export-and-project-saving}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Export and Project Saving}}}}
\begin{itemize}
\item {} 
Copy project                                  {\hyperref[\detokenize{plot_func:plot_func.TA.Copy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Copy()}}}}}

\item {} 
Save Project as hdf5                  {\hyperref[\detokenize{plot_func:plot_func.TA.Save_project}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Save\_project()}}}}}

\item {} 
Save Plots                                    {\hyperref[\detokenize{plot_func:plot_func.TA.Save_Plots}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Save\_Plots()}}}}}

\item {} 
Save Plots as Powerpoint              {\hyperref[\detokenize{plot_func:plot_func.TA.Save_Powerpoint}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Save\_Powerpoint()}}}}}

\item {} 
Save/export data as ascii/text        {\hyperref[\detokenize{plot_func:plot_func.TA.Save_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Save\_data()}}}}}

\end{itemize}

\end{itemize}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{structure}.png}
\end{figure}


\chapter{Opening of data}
\label{\detokenize{Opening:opening-of-data}}\label{\detokenize{Opening::doc}}
A key challenge in using a non graphical programming software is to locate files.
This tool provides a mixed interface to solve this challenge.
Each of the following function has a “Gui” keyword that can trigger a standard file
opening dialogue. Alternatively the filenames can be written together with an (optional)
path argument.
If the analysis uses the from us provided workflow notebooks, then we suggest that a fresh notebook
is used for each particular analysis and that the notebook is copied close to the data.

All import functions provide a wide variety of options to adapt for data formats. If a particular option is missing,
please contact the developers via email or raise an issue on github for it to be added.
The formats of the example file have the spectral information as the first row,
the time vector as first entrance of each of the following rows and are separated by tab.
Files of this type can be read without any further adaption (using the standard parameter).


\section{Opening single file and creating TA object}
\label{\detokenize{Opening:opening-single-file-and-creating-ta-object}}
Open single file:                       {\hyperref[\detokenize{plot_func:plot_func.TA.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.TA()}}}}}

Typical use of the tool is based upon an object containing all
parameter, functions and the data. This object is created by importing a
data file using this function.

The filename can be either provided as a string, with the (optional) path to other folders given.
Using the keyword “gui” instead of a filename opens the graphical file selection interface.
The function can either open a text style format (using any file ending) or the internally used “hdf5” file format.
The latter is exclusively used as internal storage formate that stores the complete project including the RAW data.

After import of either filetype the missing parameter in the “TA” object are set with the
{\hyperref[\detokenize{plot_func:plot_func.TA.__make_standard_parameter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.\_\_make\_standard\_parameter()}}}}} function.


\section{Opening multiple files}
\label{\detokenize{Opening:opening-multiple-files}}
Open many files:                        {\hyperref[\detokenize{plot_func:plot_func.GUI_open}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.GUI\_open()}}}}}

Sometimes multiple files are to be opened. Typical use examples are the options to compare different
measurements or analysis runs. This function provides a convenient way to create a list of opened projects.
One can
\begin{itemize}
\item {} 
open a gui and select multiple saved projects, which are returned as a list

\item {} 
given a list of project names to open them

\item {} 
open all files in a given folder

\end{itemize}

The general behavior is selected by the first parameter (project\_list)
For more details see the examples in {\hyperref[\detokenize{plot_func:plot_func.GUI_open}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.GUI\_open()}}}}}


\section{Opening and handling single scans}
\label{\detokenize{Opening:opening-and-handling-single-scans}}
Combine many scans:                     {\hyperref[\detokenize{plot_func:plot_func.Summarize_scans}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.Summarize\_scans()}}}}}

Typically the experiments consists of a larger number of scans that are combined into a single experimental file.
The function “Summarize\_scans” reads, selects and eventually combines a
series of single scans with a bunch of useful options. The essential idea is
that for each scan one or two numbers are generated through integration of the intensity
in a temporal and spectral window. This single number is plotted as function against the scan number.
Then either a list of numbers or a GUI is used to select the scans that are
removed from the average. A number of opening and selection options are given.

This function could also be used to combine a number of different experiments.


\chapter{Shaping of Data}
\label{\detokenize{Shaping:shaping-of-data}}\label{\detokenize{Shaping::doc}}
In the Following sections we discuss the parameter and values that are used to
filter and shape measured data. In general all loaded data read is
stored in the un\sphinxhyphen{}altered “ta.ori\_ds”. A second matrix for the same data
is created named ta.ds.

Only the function “Filter\_data” works on the dataset ds\_ori and ds.
The chirp correction creates a new ds from ds\_ori.
The background correction is applied to ta.ds (unless a
specific matrix is given´). All other parameter are only applied during a
function and do not alter ta.ds. That means that in each of the
plotting/fitting functions a local copy of the ta.ds is created (using
the function sub\_ds) to which all the shaping is applied.

\sphinxstylestrong{The intended work flow is:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
loading of data {\hyperref[\detokenize{Opening:opening-of-data}]{\sphinxcrossref{\DUrole{std,std-ref}{Opening of data}}}}

\item {} 
Filtering of data {\hyperref[\detokenize{Shaping:bad-data-filter}]{\sphinxcrossref{\DUrole{std,std-ref}{Bad data Filter}}}}

\item {} 
(optional) chirp correction {\hyperref[\detokenize{Shaping:arrival-time-correction}]{\sphinxcrossref{\DUrole{std,std-ref}{Arrival time correction}}}}

\item {} 
(optional) Background correction {\hyperref[\detokenize{Shaping:background-subtraction}]{\sphinxcrossref{\DUrole{std,std-ref}{Background subtraction}}}}

\item {} 
setting of parameter for fit {\hyperref[\detokenize{Shaping:data-shaping-settings-that-affect-the-fits}]{\sphinxcrossref{\DUrole{std,std-ref}{Data shaping settings that affect the fits}}}}

\item {} 
setting of parameter for plot {\hyperref[\detokenize{Plotting:plot-shaping-options-without-influence-on-the-fitting}]{\sphinxcrossref{\DUrole{std,std-ref}{Plot shaping options without influence on the fitting}}}}

\item {} 
all the plotting/fitting. {\hyperref[\detokenize{Plotting:plotting-functions}]{\sphinxcrossref{\DUrole{std,std-ref}{Plotting functions}}}} and {\hyperref[\detokenize{Fitting:fitting-parameter-optimization-and-error-estimation}]{\sphinxcrossref{\DUrole{std,std-ref}{Fitting, Parameter optimization and Error estimation}}}}

\item {} 
saving/exporting {\hyperref[\detokenize{Saving:data-export-and-project-saving}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Export and Project Saving}}}}

\end{enumerate}

The point 5 and 6 (Parameter) can be easily changed many times and a new plot/fit
generated. Important to not is that the parameter are stored with the object.
This means that a parameter that is explicitly set, will stay until it is
overwritten or the object is fresh loaded. So if e.g. commenting out a certain
parameter does not return the value to its Default “None”. The Parameter needs
to be set explicitly to:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ta}\PYG{o}{.}\PYG{n}{intensity\PYGZus{}range} \PYG{o}{=} \PYG{l+m+mf}{3e\PYGZhy{}3}
\PYG{c+c1}{\PYGZsh{}ta.intensity\PYGZus{}range = 3e\PYGZhy{}3 \PYGZsh{}no effect}
\PYG{n}{ta}\PYG{o}{.}\PYG{n}{intensity\PYGZus{}range} \PYG{o}{=} \PYG{k+kc}{None}
\end{sphinxVerbatim}

Often it is faster to reload the object by choosing “run all above” in the
Notebook.


\section{Bad data Filter}
\label{\detokenize{Shaping:bad-data-filter}}
Filter bad data:                                {\hyperref[\detokenize{plot_func:plot_func.TA.Filter_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Filter\_data()}}}}}

In some cases there are bad data points or other strange things. NA
values will normally be replaced by 0 during import and all data is
converted into floats during import. In many recording software
(including Pascher instruments) a specific \sphinxstylestrong{value} is used to indicate
that something went wrong. This function filters everything bigger than
this value as error. Real “NaN” values are filtered during the import of Data.
There is the option to either drop the times that contain bad values or to replace
bad values with a specific value. There is the option to put a uppervalue, lowervalue
or a single value that is then used for upper and (as negative) for the lower value.

If the filtering does not work, a manual way of filtering is
ta.ds (the chirp corrected data) or ta.ds\_ori{[}ta.ds\_ori\textgreater{}20{]}=0 is the classical way to filter


\section{Arrival time correction}
\label{\detokenize{Shaping:arrival-time-correction}}
Correct arrival time (Chirp)    {\hyperref[\detokenize{plot_func:plot_func.TA.Cor_Chirp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Cor\_Chirp()}}}}}

\sphinxstyleemphasis{Cor\_Chirp} is a powerful Function to correct for a different arrival times of
different wavelength (sometimes call chirp).

In general if a file is opened for the first time this function is opening
a plot and allows the user to select a number of points, which are then
approximated with a 4th order polynomial and finally to select a point
that is declared as time zero. The observed window as well as the intensities
and the colour map can be chosen to enable a good correction. Here a fast
iterating colour scheme such as “prism” is often a good choice. In all of the
selections a left click selects, a right click removes the last point and
a middle click (sometime appreviated by clicking left and right together)
finishes the selection. If no middle click exists, the process
automatically ends after max\_points (40 preset).

After the first run the polynom is stored in self.fitcoeff, a new matrix
calculated from self.ds\_ori that is stored as self.ds and a file stored in the
same location as the original data. The second time the function \sphinxstyleemphasis{Cor\_Chirp} is
run the function will find the file and apply the chirp correction automatically.

If one does want to re\sphinxhyphen{}run the chirp correction the function \sphinxstyleemphasis{Man\_Chirp} does
not look for this file, but creates after finishing a new file.

Alternatively the polynom or a filename can be given that load a chirp correction
(e.g. from a different run with the same sample).
The function \sphinxstyleemphasis{Cor\_Chirp} selects in the order:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
“fitcoeff”

\item {} 
“other files”

\item {} 
“stored\_file”

\item {} 
call Man\_Chirp (clicking by hand)

\end{enumerate}

Correct arrival time (Chirp)    {\hyperref[\detokenize{plot_func:plot_func.TA.Cor_Chirp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Cor\_Chirp()}}}}}
Manual overwrite arrival time correction        {\hyperref[\detokenize{plot_func:plot_func.TA.Man_Chirp}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Man\_Chirp()}}}}}


\section{Background subtraction}
\label{\detokenize{Shaping:background-subtraction}}
Background correction:                  {\hyperref[\detokenize{plot_func:plot_func.TA.Background}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Background()}}}}}

This tool is one of two ways to remove a flat background from the data (typically seen before t=0).
This tool averages for each measured  wavelength separately the values from ‘lowlimit’ to ‘uplimit’ and
subtracts it from the data. The low and uplimit can be set
anywhere to substract any background. (so one could e.g. substract a product
instead) It is important to note that many problems during measurements might
be visible in the data before time zero. So I recommend to first
plot without background correction and only after this inspection
apply the background correction.
The fit function has its own way to calculcate and apply a background
That could be used instead (but making the fit less stable)


\section{Data shaping settings that affect the fits}
\label{\detokenize{Shaping:data-shaping-settings-that-affect-the-fits}}
in general the data is handled in each of the plotting/fitting functions
separately. In each function a copy of the matrix with the limitation
below is created.
A number of parameter cut and potentially rebin the raw measured data and as such affet the fit.
The typical workflow would therefore be to adjust these parameter before the fitting stage using the
RAW plotted fits as a feedback.
\begin{itemize}
\item {} 
Cut the outside limits of the spectrum: \sphinxstyleemphasis{Bordercut}

\item {} 
Blank one or multiple regions in the spectrum (e.g. suppress scatter) \sphinxstyleemphasis{Scattercut}

\item {} 
Cut the outside of the time axis: \sphinxstyleemphasis{timelimits}

\item {} 
Blank one or multiple temporal regions (e.g. around t=0) \sphinxstyleemphasis{ignore\_time\_region}

\item {} 
rebin the temporal axis (useful for e.g. steady state long term UV\sphinxhyphen{}vis data) \sphinxstyleemphasis{time\_bin}

\item {} 
rebin the spectral axis (useful for prism based spectrometer) \sphinxstyleemphasis{wave\_nm\_bin}

\end{itemize}

For further details and examples see: {\hyperref[\detokenize{plot_func:plot_func.TA.__make_standard_parameter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.\_\_make\_standard\_parameter()}}}}}
or e.g. the general plotting function {\hyperref[\detokenize{plot_func:plot_func.plot_raw}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.plot\_raw()}}}}}.

The parameter that only change the plots are discussed in {\hyperref[\detokenize{Plotting:plot-shaping-options-without-influence-on-the-fitting}]{\sphinxcrossref{\DUrole{std,std-ref}{Plot shaping options without influence on the fitting}}}}


\chapter{Plotting functions}
\label{\detokenize{Plotting:plotting-functions}}\label{\detokenize{Plotting::doc}}\begin{itemize}
\item {} 
Plotting non Fitted data:     {\hyperref[\detokenize{plot_func:plot_func.TA.Plot_RAW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Plot\_RAW()}}}}}

\item {} 
Plotting Fitted data:         {\hyperref[\detokenize{plot_func:plot_func.TA.Plot_fit_output}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Plot\_fit\_output()}}}}}

\item {} 
Adjust fonts in plots:                {\hyperref[\detokenize{plot_func:plot_func.changefonts}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.changefonts()}}}}}

\end{itemize}

One core function of this tool is to create plots for evaluation and
publication. Internally there are a number of separate functions that
create each plot type (see below). The methods Plot\_RAW and Plot\_fit\_output
wrap the parameter into the object and simplify their use. Two additional functions
provide additional features. Both “Save\_Plots” and “Save\_Powerpoint” are
calling both plot functions and dump their output into separate figure files or two
slides of a power point file.

Common to both plotting function is that either a single plot can be called by giving
the plotting parameter or a series of plots (Default) by giving a list of number with
e.g. “range(3)”.

Most of the plot defining parameter (like, what for which wavelength the kinetic
is plotted or at what times the kinetics are extracted are defined by the
:ref:´Plot shaping options without influence on the fitting´.


\section{Plot\_RAW}
\label{\detokenize{Plotting:plot-raw}}
{\hyperref[\detokenize{plot_func:plot_func.TA.Plot_RAW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Plot\_RAW()}}}}} plots all raw figures. The different figures can be called
separately or with a list of plots (standard) e.g. plotting=range(4)
call plots 0\sphinxhyphen{}3, plotting=1 a single plot. The plots have the following
numbers: 0 \sphinxhyphen{} Matrix, 1 \sphinxhyphen{} Kinetics, 2 \sphinxhyphen{} Spectra, 3 \sphinxhyphen{} SVD. The plotting
can take all parameter from the “ta” object. See:
{\hyperref[\detokenize{plot_func:plot_func.TA.Plot_RAW}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Plot\_RAW()}}}}}


\section{Plot\_fit\_output}
\label{\detokenize{Plotting:plot-fit-output}}
{\hyperref[\detokenize{plot_func:plot_func.TA.Plot_fit_output}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Plot\_fit\_output()}}}}} plots the fit results. For this is uses the data
contained in the shaped and cut datasets that were used for the fit,
including all rebinning or temporal restrictions. The figures can be
called separately or with a list of plots (standard)
The plotting function takes all parameter from the object.
\begin{quote}

{\hyperref[\detokenize{plot_func:plot_func.TA.Plot_fit_output}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Plot\_fit\_output()}}}}}
\end{quote}

\sphinxstylestrong{Contents of the plots}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
DAC contains the assigned spectra for each component of the fit. For
a modelling with independent exponential decays this corresponds to
the “Decay Associated Spectra” (DAS). For all other models this
contains the “Species Associated Spectra” (SAS). According to the
model the separate spectra are labeled by time (process) or name, if
a name is associated in the fitting model.

\item {} 
summed intensity. All wavelength of the spectral axis are summed for
data and fit.

\item {} 
plot kinetics for selected wavelength

\item {} 
plot spectra at selected times

\item {} 
plots matrix (measured, modelled and error Matrix). The parameter are
the same as used for the corresponding RAW plot with the addition of
“error\_matrix\_amplification” which is a scaling factor multiplied
onto the error matrix.

\item {} 
concentrations. In the progress of the modelling/fitting a matrix is
generated that contains the relative concentrations of the species
as function of time.

\end{enumerate}

This function is a convenience function and is suppose to be used in
conjunction with the object and the embedded parameter (see above). The
use of qt as backend allows the easy customization of the plots via the
GUI. If the plots are saved as “svg” they can easily be adjusted in
inkscape or similar afterwards.
For more details see: {\hyperref[\detokenize{plot_func:plot_func.TA.Plot_fit_output}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Plot\_fit\_output()}}}}}


\section{Plot shaping options without influence on the fitting}
\label{\detokenize{Plotting:plot-shaping-options-without-influence-on-the-fitting}}
In addition to the general shaping parameter from section {\hyperref[\detokenize{Shaping:data-shaping-settings-that-affect-the-fits}]{\sphinxcrossref{\DUrole{std,std-ref}{Data shaping settings that affect the fits}}}}
a number of parameter only affect one or multiple of the plots but not the fitting of the data.
\begin{itemize}
\item {} 
The plotting of the kinetics is governed by the selection of the wavelength in the list \sphinxstylestrong{rel\_wave}
and the width of each \sphinxstylestrong{wavelength\_bin}

\item {} 
The plotting of the spectra is governed by the selection of the timepoint in the list  \sphinxstylestrong{rel\_time}
and potentially a percentual binning around this time\sphinxhyphen{}point with \sphinxstylestrong{time\_width\_percent}. If this is set to 0
then the measured timepoint is used.

\item {} 
The intensity (color) in the 2 plots as well as the height of the y\sphinxhyphen{}axis is determined by the \sphinxstylestrong{intensity\_range}
parameter that can be set symmetric or a\sphinxhyphen{}symmetric for best representation. With \sphinxstylestrong{log\_scale}
This intensity can be scaled logarithmic and \sphinxstylestrong{error\_matrix\_amplification} only amplifies the intensity of the
difference matrix (measured\sphinxhyphen{}fitted) in the 2d plots

\item {} 
The color scheme can be set very flexible using the Matplotlib palets, or a manually provided color scheme
(e.g. university colors)

\item {} 
The titles of all plots are chosen either by the filename or can be given flexible in each plotting functions
through the title parameter. All the plots can be automatically saved if \sphinxstylestrong{save\_figures\_to\_folder} is set to True,
Which is useful for fast surveys, otherwise the method {\hyperref[\detokenize{plot_func:plot_func.TA.Save_Plots}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Save\_Plots()}}}}}
stores all plots (see {\hyperref[\detokenize{Saving:data-export-and-project-saving}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Export and Project Saving}}}}). The axis labels are accessible via the \sphinxstylestrong{baseunit}
and the Fonts are accessible via the function {\hyperref[\detokenize{plot_func:plot_func.changefonts}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.changefonts()}}}}}

\end{itemize}


\section{extended Raw plotting}
\label{\detokenize{Plotting:extended-raw-plotting}}
\sphinxcode{\sphinxupquote{self.Plot\_raw()}} is an extended function. All the parameters are
accessible (and need then to be set manually). This function also plots a single
or multiple plots bzt setting the “plotting” parameter.

There are even more detailed manipulations possible by using the
separate plot functions:
\begin{itemize}
\item {} 
for plotting kinetics at fixed wavelength: {\hyperref[\detokenize{plot_func:plot_func.plot1d}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.plot1d()}}}}}

\item {} 
for plotting spectra at selected times {\hyperref[\detokenize{plot_func:plot_func.plot_time}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.plot\_time()}}}}}

\item {} 
for plotting the data matrix {\hyperref[\detokenize{plot_func:plot_func.plot2d}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.plot2d()}}}}}

\item {} 
for plotting the 3 fit data matrix {\hyperref[\detokenize{plot_func:plot_func.plot2d_fit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.plot2d\_fit()}}}}}

\item {} 
for the SVD plots. {\hyperref[\detokenize{plot_func:plot_func.SVD}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.SVD()}}}}}

\end{itemize}

Each of the functions allows to hand in an axis and thus plot multiple things


\chapter{Fitting, Parameter optimization and Error estimation}
\label{\detokenize{Fitting:fitting-parameter-optimization-and-error-estimation}}\label{\detokenize{Fitting::doc}}
Fitting data:                           {\hyperref[\detokenize{plot_func:plot_func.TA.Fit_Global}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Fit\_Global()}}}}}

One of the main functions of this program is to perform Global analysis
of one or multiple datasets. The fitting function is in its current
implementation embedded in the TA object and uses the parameter control
options of an lmfit parameter object as an essential tool. (my thanks to Matthew
Newville and colleagues for creating this phantastic tool) {[}M. Newville,
T. Stensitzki, D. B. Allen, A. Ingargiola, 2014. DOI:
10.5281/ZENODO.11813.{]}. To excecute an Optimization/Fit these essential
steps have to be followed (assuming that “ta” is your object):
\begin{description}
\item[{Model}] \leavevmode
you have to define a model by setting ta.mod=”internal model name”
for one of the internal models, of by setting
ta.mod=external\_function to an external function. For the internal
models three standards are implemented: “exponential”, “consecutive”
and “full\_consecutive”. (see below). The external function will
receive a vector named “times” and parameter pandas.DataFrame named
“pardf”. It is expected to return a DataFrame with the times as index
and in the columns an expression of the relative concentrations. The
external function can reload whatever data is desired. The names of the
columns are used in all plots and reports. (see below a description
of the example functions defined in “plot\_func\_function\_library.py”)

\item[{Parameter}] \leavevmode
For handling of Parameters I am using the lmfit Parameter objects to
have a flexible and fast Parameter handling toolset. The general
steps are: create a Parameter object (or use an existing parameter
object) set starting values and (optional) limits, relative
expressions and vary = True (if the parameter is to be optimised) (see below
for more details

\item[{Trigger the fitting}] \leavevmode
To trigger the fitting the function ta.Fit\_Global() is called. The
fitting function will display its results on the screen and write
them into the TA object. first it will create an parameter object
ta.par\_fit that contains the optimum parameter and can be used later,
second it writes the result dictionary ta.re. In this dictionary it
adds a number of results and parameters that are useful (see below
for further details) A number of error catching routines are build in
the fitting software. However it does sometimes (rare) come to
crashes. Then please adjust the parameter and or read the error
message. Important to notice is that this is a refinement of
parameter using an algorithm. Limiting the region where parameter can
be and choosing good starting values is essential to obtain reliable
results. (see below)

\end{description}

The general Modelling/Fitting process happens with the same approach for
internal models as well as for externally provided functions. Other
fitting processes like the optimization of the arrival time correction
are discussed further down in this document.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
First a copy of the Data\sphinxhyphen{}Matrix ta.ds is created with the shaping
parameters

\item {} 
Then a Matrix is created that represents the fractional population of
each species (or process in case of the paral model). This Matrix
contains one entry for each timepoint and represents the kinetic
model based upon the starting parameter. (see below for a description
of the models). This model formation can by done by using a build in
or a user supplied function. (handled in the function “pf.build\_c”)

\item {} 
Then the process/species associated spectra for each of the species
is calculated using the linalg.lstsq algorithm from numpy
(\sphinxurl{https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html})

\item {} 
From the convoluted calculated species concentrations and spectra a
calculated matrix is formed (handled in the function “pf.fill\_int”)

\item {} 
The difference between calculated and measured spectra is calculated,
point\sphinxhyphen{}wise squared and summed together. (function “err\_func”)

\item {} 
This difference is minimized by iterating 2\sphinxhyphen{}4 with changing
parameters using an optimization algorithm (generally nelder\sphinxhyphen{}mead
simplex)

\item {} 
Finally in a last run of 2\sphinxhyphen{}5 the final spectra are calculated (using
the “final” flag) and the optimized parameter, the matrixes
(“A”\sphinxhyphen{}measured, “AC” \sphinxhyphen{} calculated, “AE” \sphinxhyphen{} linear error), spectra
(always called DAS) the concentrations (called “c”) are written in
the dictionary “ta.re” together with a few representations and other
fit outputs. The optimized parameter are also written into ta.par\_fit
(as an parameter object) that can be re\sphinxhyphen{}used as input into further
optimization steps.

\end{enumerate}

The choice to use lmfit parameters allows the flexible handling of
constraints and freezing/releasing of parameter. (see below). Additional
fitting options include the fitting of the parameter of the arrival time
correction, the use of advanced optimization algorithms, and the
possibility to fit multiple datasets together.


\section{Description of models}
\label{\detokenize{Fitting:description-of-models}}

\subsection{internal kinetic models}
\label{\detokenize{Fitting:internal-kinetic-models}}
The internal kinetic models are created to be highly flexible. The
program recognizes all parameter that are “rates” by recognizing the
names with “k” followed by one or multiple digits. The program starts at
“k0” and then uses “k1”,”k2”,… in an un\sphinxhyphen{}interrupted series. If one key
is missing the program stops searching for more. However that offers the
fast and easy possibility to add additional components to the fit by
adding new parameters with an increasing number. All rates are to be
given as rates and are assumed to be in the same units as is the
measured matrix. So if the measured data is in picoseconds, the rates
are in \(ps^-1\). See section {\hyperref[\detokenize{Shaping:data-shaping-settings-that-affect-the-fits}]{\sphinxcrossref{\DUrole{std,std-ref}{Data shaping settings that affect the fits}}}}
for more information.

\sphinxstylestrong{ta.mod=”exponential”} In this model the data is represented by
independent exponential decays. For each component the a symmetric
response function is formed (error function) using the the parameter
“resolution” as characteristic width (corresponding to 2 x
\(\sigma\)) with with “t0” as the point of 50\(\%\) rise from
0. At the time 1 x resolution the signal is 97.8\(\%\). This rise
is convoluted with an exponential decay function per given decay
constant. The integral signal of the error function is 1, to which all
the decays are set (assuming that they do not decay faster than 2x
resolution) The extracted Spectra are commonly called decay associated
spectra (DAS). Their relative intensity is corresponding with the
exponential pre\sphinxhyphen{}factors for single exponential fits to the data (for
each wavelength). Additional parameter that can be set are “background”
(assuming a species that is constantly “1”) and “infinite” a species
that is rising with the response function and then constant “1”.

\sphinxstylestrong{ta.mod=”consecutive”} This fit assumes a model of consecutive
exponential decays. A response function with “t0” = 50\(\%\) rise
is formed that rises symmetric to \(2\sigma \approx 98\%\) (of 1) at
1 x the parameter “resolution” followed by A\sphinxhyphen{}\textgreater{}B\sphinxhyphen{}\textgreater{}C consecutive decay.
This particular model uses a preudo approach to this fit to speed up the
calculations. The parameter are optimised by modelling an “exponential”
model (see above) followed by a single step of a “true consecutive”
decay (see below). This approach is quite representative unless there
are fast components of the order of the response function involved in
the process and the different processes are clearly separated (each rate
one of magnitude separated). Additional parameter that can be set are
“background” (assuming a species that is constantly “1”) and “infinite”
a species that is with the last decay constant to a constant “1” and not
decaying.

\sphinxstylestrong{ta.mod=”full\_consecutive”} This fit assumes a model of consecutive
exponential decays. A response function with “t0” = 50\(\%\) rise
is formed that rises to \(2\sigma \approx 98\%\) (of 1), at 1x the
parameter “resolution” followed by A\sphinxhyphen{}\textgreater{}B\sphinxhyphen{}\textgreater{}C consecutive decay. This model
is formed by a stepwise integrated differential equation and represents
the “true” sequential model. The “rise” is simulated by sampleing a true
gaussian function and adding the appropiate fraction to the excited
state. Arbitrary pulse/response shapes can be sampled in the advanced
functions. Additional parameter that can be set are “background”
(assuming a species that is constantly “1”) and “infinite” a species
that is with the last decay constant to a constant “1” and not decaying.


\subsection{external kinetic models as defined in example file “plot\_func\_function\_library.py”}
\label{\detokenize{Fitting:external-kinetic-models-as-defined-in-example-file-plot-func-function-library-py}}
External model functions can be written and used to create the matrix of
populations. The external function will receive a vector named “times”
and a pandas.DataFrame with the columne “value” named “pardf”. It is
expected to return a DataFrame with the times as index and in the
columns the an expression of the relative concentrations. The parameters
have a name and a float value. The external function can however load
whatever other data is required. We have for example modelled
spectro\sphinxhyphen{}electro\sphinxhyphen{}chemistry data by reading the current from cyclic
voltametry and using the value to extract a number representing the
concentration of a certain species. An important feature of external
functions are that columns in the DataFrame can be labeled with names.
These names will be used in the plots and significantly improve the work
with complex models. The parameter that are given to the functions can
be name arbitrarily but must match:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{z\PYGZus{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{z} \PYG{l+m+mi}{0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{9}\PYG{n}{\PYGZus{}}\PYG{p}{]}\PYG{o}{*}
\end{sphinxVerbatim}

meaning, it must start with a letter and can only contain (small) letters,
numbers and “\_”. Important is that in order allow for some of the parameter
settings (see section :ref:’Setting of Fit parameter’) if the first
letter is a “k” and the second string is a number the parameter will be
interpreted as a rate. (recognition is done by:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bool(re.match(re.compile(’[k]\PYGZsq{}̣), parameter\PYGZus{}name[:2])
\end{sphinxVerbatim}

In the file “plot\_func\_function\_library.py” we provide a number of
useful example functions that show how to model a variety of different
cases. In general there is no restriction to what type of function can
be modelled here, but all these examples are based upon transient
absorptions spectroscopy. In these examples we model the instrument
response by a gaussian pulse. In general, any pulse shape could be
loaded from an external file. In these examples we sample the
differential change of a concentration by writing the differential for
the dynamics. The excitation is then represented by sampling the
gaussian pulse and “raising” a certain fraction of the molecules into
the excited state. As the gaussian used here is normalized to have the
integral of “1”, the total initial concentration is “1” and the numbers
in this matrix representative with a “fractional population”. Each step
in the code is documented and the code can be adapted easily to a wide
variety of problems. The example functions provided are
\begin{itemize}
\item {} 
\sphinxstylestrong{manual\_consecutative}
An example how a stepwise consecutative decay would look like.

\item {} 
\sphinxstylestrong{Square\_dependence}
An example in which the pumping “pulse” is scaled by a parameter and
a non linear decay is included (e.g. recombination)

\item {} 
\sphinxstylestrong{gaussian\_distribution}
A model where a substance is excited into a state, followed by a
linear decays step into a state that decays with a distribution of
rates (here assumed gaussian) into a final, non decaying state. These
type of complex decays are often observed in protein folding

\end{itemize}

\sphinxstylestrong{Usage of external functions:} To use an external function, this
function needs to be handed to ta.mod. For an external function this
means that it has to be imported, and then handed to ta.mod. In the
example below we import an external module (the file
“plot\_func\_function\_library.py”) as “func” and then use from this
external module the function “Square\_dependence”.
All the models are extensively documented in the function library. These
functions can load any external file with additional information. It is
highly recommended to use the versatile parameter setting (see below)
to adjust models. E.g. can a certain kinetic pathway be disabled by
setting its rate to “0” and using the option “vary=False” to lock it.
(see below in the parameter section).

It is highly recommended to use the docstring (description) directly
below the definition of the model to describe what it does. This string
is stored with ta.Save\_Project and should be sufficient to identify the
model. Also if all the species are labeled (label the columns of the
returning DataFrame) These names are used throughout the plotting
functions. (please see examples for more explanation)

Remark: Importing an external function happens in python only if it has
not already been imported. So if the fitting function is adapted, either
the whole notebook/console needs to be restart, or (better) the function
should be reloaded. I recommend to use the function “reload” from the
“importlib” for this purpose (see the example below) This should happen
before the function is handed to ta.mod (as shown in the workflow
notebook).


\section{Setting of Fit parameter}
\label{\detokenize{Fitting:setting-of-fit-parameter}}
The fit parameter are a crucial point for achieving meaningful results
from an optimization. In general three different types need to be
chosen, first the model (see ) then if the rate parameter (necessarily
call k0, k1, k2, ..) will be handed into the fitting function as they
are or in log space. (ta.log\_fit) and finally the parameter themselves.
The \sphinxstylestrong{log\_fit} option can be important as it brings widely separated
rats into the very similar numerical range, simplifying the function of
the simplex optimizer. In this program all rates are limited to be above
0 independent if they are handled linearly or in log. This happens in
the begin of the fit function, here all “rates” are identified that have
the name “ki” with i =0\sphinxhyphen{}99 and then their lower limit is set to zero
(unless they have already a lower limit \textgreater{}0).

The parameter are handled as a lmfit Parameter object. Inside the
fitting function this object is converted into a pandas Dataframe that
is handed to the function generating the time dependent
“concentrations”.
\begin{itemize}
\item {} 
initialize
The lmfit parameter object needs to be initialized with
“ta.par=lmfit.Parameters()”. In the fitting function I convert the
parameter object into a DataFrame and back on several places. A
function par\_to\_pardf and pardf\_to\_par does this conversion. All the
parameter set are available through the ta.par object and can thus be
given to other fits. After the fit there is a new object calles
ta.par\_fit that contains the optimized fit results. So if you would
like to re\sphinxhyphen{}use the old results ta.par=ta.par\_fit accomplishes this.

\item {} 
add parameter
Each parameter must
have a name from:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{z\PYGZus{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{a}\PYG{o}{\PYGZhy{}}\PYG{n}{z0}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{9}\PYG{n}{\PYGZus{}}\PYG{p}{]}\PYGZbs{}\PYG{o}{*}
\end{sphinxVerbatim}

(starting with a letter and then
letters and stars and “\_”). In the included models (see
:ref:’Description of models’) parameters like “background”
and “infinite” trigger the inclusion of e.g. the background or a non
decaying component. Other parameters should be initiated with a value
that has to be of type float (number). Important to not is that the
code automatically recognizes parameter that have the name “ki” with
i and element of 0\sphinxhyphen{}99 as a rate. These rates are brought in and out
of logspace with the switch “log\_fit”. All other names can be freely
chosen. I highly recommend to do this for the sake of structure. e.g.
a “threshold” could be named as such

\item {} 
add or set
New parameter are “added” to the parameter object. Existing
parameter can be “set” to a certain value. If Set is used any of
the additional/optional things can be set alone.

\item {} 
limits min and max
Optional is the settings of limits (\sphinxstylestrong{min} and \sphinxstylestrong{max}). If a limit
is set the parameter will stay within the limit, even if a starting
value outside the limit is given! Important to note is that after
each optimization that included limits the results should be checked
if the limits were reached. (the printed output states the limits).
Limits are very important for the more advanced optimizers like AMPGO
(see section :ref:trigger\sphinxhyphen{}the\sphinxhyphen{}fit. The parameter tunneling
uses these limits as guidelines.

\item {} 
Vary=True/False
Very useful is the option “vary=True/False”. This switch freezes the
parameter, or allows it to be optimized by the algorithm. In the
progress of an analysis one often freezes a parameter to develop a
stable model and releases this parameter later. Particular the
parameter “t0” which is in my models the starting point and
“resolution”, which is in my models the instrument response function
are parameter that are often frozen in the beginning. Fitting with
them enabled significantly extends the duration for finding a stable
fit. Often I first plot the function with the starting parameter,
temporarily setting all parameter to vary=False with the trick below,
to then step by step enable the optimization, while the starting
parameter are adapted.

\item {} 
expr
An advanced option is the setting of expressions. This are relations
to other parameter. e.g. expr=’k0’ sets the value of the current
parameter always the same as “k0”. The values are always given as
string so expr=’1\sphinxhyphen{}k0’ sets the value to 1 \sphinxhyphen{} the value of “k0”. Please
see the documentation of lmfit for further details

\end{itemize}

Very useful trick to set temporarily set all parameter to vary=False to
test e.g. starting conditions and then enable the optimization of a
single parameter. As here the “set” is used, the parameter can be
initially added with a different value. (see workflow notebook for
further examples).


\section{storing of fit results}
\label{\detokenize{Fitting:storing-of-fit-results}}\begin{itemize}
\item {} 
ta.par
always contains the initial fit parameter (parameter object)

\item {} 
ta.par\_fit
contains the fit results and can be directly re\sphinxhyphen{}used with
ta.par=ta.par\_fit (parameter object)

\item {} 
ta.re{[}’fit\_results\_rates’{]}
contains the fit results in a neatly formated DataFrame in the form
of rates

\item {} 
ta.re{[}’fit\_results\_times’{]}
contains the fit results in a neatly formated DataFrame in the form
of decay times (1/rates)

\item {} 
ta.re{[}’fit\_output’{]}
Is the results oject of the fit routine. It can be called and then
shows details like number of iterations, chi\(^2\), fit
conditions and a lot more. This object is stored after a fit but is
NOT saved by ta.Save\_Project!

\end{itemize}


\section{Trigger the Fit}
\label{\detokenize{Fitting:trigger-the-fit}}
The Fitting process is triggered by calling the function “Fit\_Global”.
if the parameter were set as part of the object that contains this Fit
(as is usually the case with ta.par), than just calling the function
without any other parameters is a good choice. Internally the Fit
function is making a copy of the parameter and shapes the data, then it
optimized single or multiple datasets. As standard it uses the Nelder
Mead Simplex algorithm to minimize the error values defined by the
function pf.err\_func and pf.err\_func\_multi. Currently the maximum
iterations are hard\sphinxhyphen{}coded to be max 10000. I have not needed more than
1000 for any well defined problem. The optimizer can be changes to
“Ampgo” that offers an advanced “tunneling” algorithm for checking for
global minima. Important for this to work properly all optimizing
parameter need “min” and “max” definitions. Parameter can additionally
be given via the parameter and module input at this stage, but in
general it is better to define them as part of the ta object. The
pf.err\_func and pf.err\_func\_multi recognise if an internal or an
external fitting model is to be used by checking if “ta.mod” (or the
here given “mod”) are strings or something else (in which case it
assumes it is an external function). Additional modules from \sphinxurl{https://lmfit.github.io/lmfit-py/fitting.html}
can be easily implemented.

See section
{\hyperref[\detokenize{Fitting:external-kinetic-models-as-defined-in-example-file-plot-func-function-library-py}]{\sphinxcrossref{\DUrole{std,std-ref}{external kinetic models as defined in example file “plot\_func\_function\_library.py”}}}}
for examples how to define those. The fitting process is in all cases
the same. Advanced options include the use of fit\_chirp that runs
multiple iterations of chirp fitting and global fitting iterative (to a
maximum of fit\_chirp\_iterations), or the multi\_project module (see
below). In general the dump\_paras can be used to write into the working
directory a file with the current fitting parameter and the optimum
achieved fitting parameter. This is intended for long and slow
optimizations to keep a record of the fits even if the fitting process
did not finish.

{\hyperref[\detokenize{plot_func:plot_func.TA.Fit_Global}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Fit\_Global()}}}}}


\section{Fitting multiple measured files at once}
\label{\detokenize{Fitting:fitting-multiple-measured-files-at-once}}
To fit multiple projects the fit function needs to get a number of
projects. These can of course be opened with a hand written loop. A
cleaner way is to either use the Gui function to open a list of
files. {\hyperref[\detokenize{Opening:opening-multiple-files}]{\sphinxcrossref{\DUrole{std,std-ref}{Opening multiple files}}}}
As each file needs a chirp correction and these things I
recommend to use saved projects (hdf5 files) for this purpose. Please see
the function documentation for further details. In general this function is
fitting each of the projects separately, but using the same parameter. This means
that in general a new (different) DAS is calculated for each of the measurements.

To work with the same DAS for the measured and calculated matrices need to be
concatenated before the fitting. A convenient way to do this is to use the
shaped matrices (potentially with different scattercuts) and the concentrations
that are created after an individual fit:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} without scaling::}
\end{sphinxVerbatim}
\begin{quote}

A\_con=ta\_list{[}0{]}.re{[}‘A’{]}
c\_con=ta\_list{[}0{]}.re{[}‘c’{]}
\end{quote}

\# With scaling:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A\PYGZus{}con}\PYG{o}{=}\PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{p}{[}\PYG{n}{ta\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{re}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ta\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{re}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{ta\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{re}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mf}{0.4}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{c\PYGZus{}con}\PYG{o}{=}\PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{p}{[}\PYG{n}{ta\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{re}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ta\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{re}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ta\PYGZus{}list}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{re}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\# using the “fill\_int” function calculates just the DAC:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{re}\PYG{o}{=}\PYG{n}{pf}\PYG{o}{.}\PYG{n}{fill\PYGZus{}int}\PYG{p}{(}\PYG{n}{A\PYGZus{}con}\PYG{p}{,}\PYG{n}{c\PYGZus{}con}\PYG{p}{,}\PYG{n}{final}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

Alternatively one could give this concatenated Matrix to the Fit\_Global and construct
an assembled external function.


\section{Error Estimation}
\label{\detokenize{Fitting:error-estimation}}
Estimating errors correctly is based on estimating the validity of the full set of optimized parameter for this we use the F\sphinxhyphen{}statistics of the single or combined datasets to define a cutoff value. At the cutoff value the combined Chi\textasciicircum{}2 is so much larger than the minimum Chi\textasciicircum{}2 that this can not be explained statistically anymore. Practically this corresponds to making the “Null hypothesis” that all parameters are zero and if the difference of Chi\textasciicircum{}2 is statistically significant, the coefficients improve the fit
the f\sphinxhyphen{}statistics compares the number of
“fitted parameter”=number of species*number of spectral points + number of kinetic parameter
“free points”=number of datasets*number of spectral points*number of time points \sphinxhyphen{} fitted parameter
within the target quality, meaning, what fraction do my variances need to have, so that I’m 100\% * target\_quality sure that they are different from zero
This is done in the function {\hyperref[\detokenize{plot_func:plot_func.s2_vs_smin2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{plot\_func.s2\_vs\_smin2()}}}}}. The confidence level then defines the cutoff value. For each (varied) parameter a separate optimization is performed, that attempts to find the upper and lower bound at which the total error of the re\sphinxhyphen{}optimized globally fitted results reaches the by F\sphinxhyphen{}statistics defined confidence bound. Careful, this option might run for very long time. Meaning that it typically takes 50 optimization per variable parameter (hard coded limit 200) The confidence level is to be understood that it defines the e.g. 0.65 * 100\% area that the parameter with this set of values is within this bounds.


\section{Iterative Fitting}
\label{\detokenize{Fitting:iterative-fitting}}
as the fit results are written into the parameter ta.par\_fit the fit can be very conveniently
triggered in an iterative fashion. This is particularly useful for refining the chirp.
The initially achieved optimal kinetic parameters are used as starting parameter for each
global fit after the chirp optimization. e.g. a 5 times iterative improvement can be achieved with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{start\PYGZus{}error}\PYG{o}{=}\PYG{n}{ta}\PYG{o}{.}\PYG{n}{re}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n}{ta}\PYG{o}{.}\PYG{n}{par}\PYG{o}{=}\PYG{n}{ta}\PYG{o}{.}\PYG{n}{par\PYGZus{}fit}
        \PYG{n}{ta}\PYG{o}{.}\PYG{n}{Fit\PYGZus{}Global}\PYG{p}{(}\PYG{n}{fit\PYGZus{}chirp}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{ta}\PYG{o}{.}\PYG{n}{re}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{start\PYGZus{}error}\PYG{p}{:}\PYG{k}{break}
\end{sphinxVerbatim}


\section{Species Spectral Development}
\label{\detokenize{Fitting:species-spectral-development}}
A small but often useful function is {\hyperref[\detokenize{plot_func:plot_func.Species_Spectra}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.Species\_Spectra()}}}}} It takes either a TA\sphinxhyphen{}Object or a concentration and spectral DataFrame and combines the concentration with the species associated spectrum. This leads to the matrix that is contributed by this specific species. As the concentration and the spectrum are combined, this represents the indeed measured signal. Here the ds\sphinxhyphen{}parameter of the Plot\_RAW function offers a useful combination. assuming that we fitted: species 0,1,2, (or more) then:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}extract the spectra}
\PYG{n}{dicten}\PYG{o}{=}\PYG{n}{pf}\PYG{o}{.}\PYG{n}{Species\PYGZus{}Spectra}\PYG{p}{(}\PYG{n}{ta}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}plot the measured spectrum and substract the}
\PYG{c+c1}{\PYGZsh{}contribution of \PYGZdq{}1\PYGZdq{} and \PYGZdq{}2\PYGZdq{}}
\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Plot\PYGZus{}RAW}\PYG{p}{(}\PYG{n}{ds}\PYG{o}{=}\PYG{n}{ta}\PYG{o}{.}\PYG{n}{re}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{dicten}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{dicten}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{Comparative plotting}
\label{\detokenize{Comparing:comparative-plotting}}\label{\detokenize{Comparing::doc}}
The comparative plotting is an important tool to compare different
measurements (e.g. different conditions), different fits or steady state
spectra. In general you can compare different kinetics
(at one or multiple fixed wavelength) with {\hyperref[\detokenize{Comparing:compare-at-wave}]{\sphinxcrossref{\DUrole{std,std-ref}{Compare\_at\_wave}}}} ,
compare different spectra at one or multiple given timepoints with
{\hyperref[\detokenize{Comparing:compare-at-time}]{\sphinxcrossref{\DUrole{std,std-ref}{Compare\_at\_time}}}} and compare the extracted spectra (decay associated
or species associated) with {\hyperref[\detokenize{Comparing:compare-dac}]{\sphinxcrossref{\DUrole{std,std-ref}{Compare\_DAC}}}}. The essential idea is that the
parameters in the project that contains the comparative plotting are used
for all the plots. So the ta.bordercut or ta.intensity is used for all
the plot, independent of e.g. the intensity in the other projects.

New is that the compare functions take “other” as a parameter, which can
be either a single or multiple projects (TA \sphinxhyphen{} objects). These projects
need to be loaded into the program. Loading a project can be done by
having them open from prior import or analysis (e.g. when comparing different fits)
and then using

{\hyperref[\detokenize{plot_func:plot_func.TA.Copy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Copy()}}}}}

More usual other (saved) projects will be
opened with the function

{\hyperref[\detokenize{plot_func:plot_func.GUI_open}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pf.GUI\_open()}}}}}

. See {\hyperref[\detokenize{Opening:opening-multiple-files}]{\sphinxcrossref{\DUrole{std,std-ref}{Opening multiple files}}}}
for more information on that.

As this comparision very often contains a lot of files the images are
automatically saved using the filenames and the wavelength/time points.
The images are however open and if the standard approach using QT was
used can be manipulated using the GUI tools. So is e.g. the conversion
into a linear time\sphinxhyphen{}axis currently not implemented, but can easily be
achieved by changing the axis in the QT GUI.

A very important function provided by this set of tools is the comparision against
other spectra. So can for examples be reference spectra (e.g. UV\sphinxhyphen{}vis) be added to
the plots.


\section{Normalization and Scaling}
\label{\detokenize{Comparing:normalization-and-scaling}}
An important option is the normalization in a certain window that
applies for both Compare\_at\_time and Compare\_at\_wave. Very often data
needs to be normalized before it can be compared to anything e.g. to
the size of the ground state bleach or an excited state absorption.
Here I offer the normalization in a certain window in time and space.
In this window a value in the “ta” and then each of the “other”
projects is calculated. The intensity of each in the other projects
(but not of the “ta” project) is then mutliplied by the quotient of
this value in this specific window. This means e.g. that even if the
kinetics is plotted for 600nm the normalization can be performed at
1\sphinxhyphen{}2ps at 450\sphinxhyphen{}500nm. This is very useful to plot e.g. the efficiency of
product formation in the study of catalytic processes. For this
normalization a “window” needs to be defined in the order:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{Start} \PYG{n}{time}\PYG{p}{,} \PYG{n}{End} \PYG{n}{time}\PYG{p}{,} \PYG{n}{Start} \PYG{n}{wavelength}\PYG{p}{,} \PYG{n}{End} \PYG{n}{Wavelength}\PYG{p}{]}
\end{sphinxVerbatim}

Care should be take to where this normalization is performed. The region
just around t=0 is dangerous due to the artifacts, that do not represent
real values. If external values are suppose to be used for scaling, the
individual intensities can be manipulated. For each of the loaded
projects ta.ds is the matrix that contains the data. With:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ta.ds*=1.1}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

could for example the individual intensity be raised by 10\%. But be aware
that with this action you are changing the data in the object. The original
data ta.ds\_ori remains unchanged. If you save and reload the data, the intensity
will revert to the originally measured value.


\section{Compare\_at\_time}
\label{\detokenize{Comparing:compare-at-time}}
This function plots multiple spectra into the same figure at one or multiple given timepoints (rel\_time) and
allows for {\hyperref[\detokenize{Comparing:normalization-and-scaling}]{\sphinxcrossref{\DUrole{std,std-ref}{Normalization and Scaling}}}}

Very useful to compare the spectra for different solvents or quenchers, or e.g. different fits.
The ta.time\_width\_percent parameter defines if this is a single time
(if time\_width\_percent = 0) or an integrated window.

A normalization window can be given at which all the plotted curves are normalized to.
This window does not have to be in the plotted region. See {\hyperref[\detokenize{Comparing:normalization-and-scaling}]{\sphinxcrossref{\DUrole{std,std-ref}{Normalization and Scaling}}}}

Very often one would like to compare the measured spectra at a certain
time to an external spectrum (e.g. spectro\sphinxhyphen{}electro\sphinxhyphen{}chemistry or steady
state absorption). This can be done by loading a specific spectrum into
a DataFrame and handing this data Frame to the comparision function. The
function can also be used to plot e.g. the measured spectra vs. an
external spectrum without giving any “other” Projects.

For more information, details on the parameter and examples see:

{\hyperref[\detokenize{plot_func:plot_func.TA.Compare_at_time}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Compare\_at\_time()}}}}}


\section{Compare\_at\_wave}
\label{\detokenize{Comparing:compare-at-wave}}
This function plots multiple kinetics into the same figure at one or
multiple given wavelength (rel\_wave) and  allows for {\hyperref[\detokenize{Comparing:normalization-and-scaling}]{\sphinxcrossref{\DUrole{std,std-ref}{Normalization and Scaling}}}}
Very useful to compare the kinetics for different quencher concentrations or
pump powers, or e.g. different fits. The parameter width or the general ta.wavelength\_bin
defines the width of the spectral window that is integrated and shown.

A normalization window can be given at which all the plotted curves are normalized to.
This window does not have to be in the plotted region. See {\hyperref[\detokenize{Comparing:normalization-and-scaling}]{\sphinxcrossref{\DUrole{std,std-ref}{Normalization and Scaling}}}}

Often multiple wavelength are to be plotted, and if at the same time
many projects go into the same plot, things tend to get messy. As the
files are saved separately this approach proofed to be useful.

For more information, details on the parameter and examples see:

{\hyperref[\detokenize{plot_func:plot_func.TA.Compare_at_wave}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Compare\_at\_wave()}}}}}


\section{Compare\_DAC}
\label{\detokenize{Comparing:compare-dac}}
This is a convenience function to plot multiple extracted spectra (DAS
or species associated) into the same figure or into a separate figure
each. Other should be ta.plot\_func objects (loaded or copied). By
standard it plots all into the same window. If all project have the same
number of components one can activate “separate\_plots” and have each
separated (in the order created in the projects).

The “Spectra” parameter allows as before the inclusion of an external
spectrum. Others is optional and I use this function often to compare
species associated spectra with one or multiple steady state spectra.

For more information, details on the parameter and examples see:

{\hyperref[\detokenize{plot_func:plot_func.TA.Compare_DAC}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Compare\_DAC()}}}}}


\chapter{Data Export and Project Saving}
\label{\detokenize{Saving:data-export-and-project-saving}}\label{\detokenize{Saving::doc}}

\section{Save\_Plots}
\label{\detokenize{Saving:save-plots}}
Save Plots                                              {\hyperref[\detokenize{plot_func:plot_func.TA.Save_Plots}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Save\_Plots()}}}}}

Convenience function that calls both “Plot\_RAW” and if possible
“Plot\_fit\_output” and saves the plots. Effectively this is intented to
be used at the end of a quick exploratory work to capture a status. The
parameter are indentical to the two plotting functions and are handed
through.


\section{Save\_Powerpoint}
\label{\detokenize{Saving:save-powerpoint}}
Save Plots as Powerpoint                {\hyperref[\detokenize{plot_func:plot_func.TA.Save_Powerpoint}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Save\_Powerpoint()}}}}}

Convenience function that calls both “Plot\_RAW” and if possible
“Plot\_fit\_output” and saves the plots as “png”.

Then it creates a power point file with one slide for the RAW plots and
one slide for the Fits.
Effectively this is intented to be used at the end of the a quick
exploratory work to capture a status and create a quick presention
slide. The parameter are intentical to the plotting functions and are
handed through. The additional switches save\_RAW and save\_Fit are
convenience to allow for faster processing.

If the “savetype” contains ‘png’, ‘svg’, or ‘pdf’ then a summary file is created
that looks close to the powerpoint file.


\section{Saving of the  project}
\label{\detokenize{Saving:saving-of-the-project}}
Save Project as hdf5                    {\hyperref[\detokenize{plot_func:plot_func.TA.Save_project}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Save\_project()}}}}}

This software allows the saving of the TA project as a HDF5 file that
can be reloaded. The HDF5 file contains all the set parameter as well as
the fit results (if applicable) and the raw data. To reduce the space
consumption we save ta.ds\_ori and the parameter that are used to create
ta.ds. If manual changes were made to ta.ds, these have to be stored
externally. As only the obvious errors are filtered in ta.Filter\_data
this is can savely replace the original data File. We are also saving
the arrival\sphinxhyphen{}time (chirp) correction in the file and restore the chirp
corrected data ta.ds during the import. The import function understands
the file type and re\sphinxhyphen{}creates the object.

The one limitation to this method is the external fit function. If an
external \sphinxstylestrong{ta.mod} is used, the save function stores the name and the
documentation string of this function as a string. So after reloading of
the analysis object the external function will have to be set with
ta.mod=imported\_function. The parameter of the fit are however stored.
Only the filename and the path of the file can be changed during saving
of the project. If left empty the path and filename of the original
ASCII file is used.


\section{Save ASCII data}
\label{\detokenize{Saving:save-ascii-data}}
Save/export data as ascii/text  {\hyperref[\detokenize{plot_func:plot_func.TA.Save_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{self.Save\_data()}}}}}

This is a convenient function to export the data for use with other
plotting programs, the chirp corrected data, all the slices defined by
ta.rel\_wave and ta.rel\_time for both the fits and a the RAW data. The
external options include: save\_RAW,save\_Fit while there is an
automatic that recognizes if for example fit data is present, this
switch allows the manual selection which datasets are stored.
save\_slices selected if the slices defined by ta.rel\_wave and
ta.rel\_time are saved save\_binned this switch chooses if the chirp
corrected and rebinned dataset (ta.ds with ta.wavelength\_nm\_bin) is
saved. If the ta.wavelength\_nm\_bin is None, this saves the chirp
corrected RAW data. filename sets the basis filename that is used for
all the files path this can be a full path or a simple string,
defining a folder relative to the folder in ta.path. If the folder
does not exist, it will be created, if it exists a file with exactly
the same name will be overwritten without confirmation sep defines the
separator user to separate different values. Standard is a “TAP”. A good
choice would also be a space or a comma, unless you are
located in one of the countries that uses commas for decimal points.
Decimals will be separated with “dots”.

This function by default also dumps a text file with the fit results


\chapter{Function Index}
\label{\detokenize{genindex:function-index}}\label{\detokenize{genindex::doc}}

\chapter{KiMoPack \sphinxhyphen{} Functions}
\label{\detokenize{plot_func:kimopack-functions}}\label{\detokenize{plot_func::doc}}\index{TA (class in plot\_func)@\spxentry{TA}\spxextra{class in plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{TA}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{n}{path}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{sep}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textbackslash{}t\textquotesingle{}}}, \emph{\DUrole{n}{decimal}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}.\textquotesingle{}}}, \emph{\DUrole{n}{index\_is\_energy}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{transpose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sort\_indexes}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{divide\_times\_by}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{shift\_times\_by}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{external\_time}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{external\_wave}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data\_type}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{units}\DUrole{o}{=}\DUrole{default_value}{None}}}{}~\index{Background() (plot\_func.TA method)@\spxentry{Background()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.Background}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Background}}}{\emph{\DUrole{n}{lowlimit}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{uplimit}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}, \emph{\DUrole{n}{use\_median}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{ds}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{correction}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
This is the background correction. In general it for each measured
wavelength averages the values from ‘lowlimit’ to ‘uplimit’ and
subtracts it from the data. It rund on the object (global) or if
given a specific ds local.
The low and uplimit can be set anywhere to substract any background.
It is important to note that many problems during measurements might
be visible in the data before time zero. So I recommend to first
plot without background correction and only after this inspection
apply the background correction.
The fit function has its own way to calculcate and apply a background
That could be used instead (but making the fit less stable)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lowlimit}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} this is the lower limit from which the average (or median) is taken
(Default) is None, in which case the lower limit of the data is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{uplimit}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} this is the upper limit until which the average (or median) is taken
(Default) is \sphinxhyphen{}1 (usually ps), in which case the lower limit of the data is used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{use\_median}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the Median is a more outlier resistant metric in comparision to
the Mean (Average). However the values are not quite as close
to the distribution center in case of very few values. False
(Default) means the Mean is used

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ds}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if None (Default) the internal Dataframe self.ds is used,
otherwise the pandas DataFrame ds is corrected and returned

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{correction}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} this is the correction applied. It must be a DataFrame with
the same numbers of columns (spectral points) as the used ds

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

if the object self has the name “ta”

typical useage:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Background}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

specify inegrated are to \sphinxhyphen{} inf (Default) up to \sphinxhyphen{}0.5ps and use the Median for computation

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Background}\PYG{p}{(}\PYG{n}{uplimit} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{use\PYGZus{}median} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Compare\_DAC() (plot\_func.TA method)@\spxentry{Compare\_DAC()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.Compare_DAC}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Compare\_DAC}}}{\emph{\DUrole{n}{other}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{spectra}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{separate\_plots}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{cmap}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
This is a convenience function to plot multiple extracted spectra
(DAS or species associated) into the same figure or into a separate figure
each. Other should be ta.plot\_func objects (loaded or copied). By
standard it plots all into the same window. If all project have the same
number of components one can activate “separate\_plots” and have each
separated (in the order created in the projects).

The “Spectra” parameter allows as before the inclusion of an external
spectrum. Others is optional and I use this function often to compare
species associated spectra with one or multiple steady state spectra.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{other}} (\sphinxstyleliteralemphasis{\sphinxupquote{TA object}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list of those}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} should be ta.plot\_func objects (loaded or copied) and is what
is plotted against the data use a list {[}ta1,ta2,… {]} or generate this
list using the Gui function. See section {\hyperref[\detokenize{Opening:opening-multiple-files}]{\sphinxcrossref{\DUrole{std,std-ref}{Opening multiple files}}}} in
the documentation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{spectra}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If an DataFrame with the wavelength as index is provided, Then the spectra of each column
is plotted into the differential spectra 1:1 and the column names are used in the legend
Prior scaling is highly suggested. These spectra are not (in general) scaled with the
norm window. (see examples)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{separate\_plots}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} True or False (Default), separate plots is the switch that decides if a axis or
multiple axis are used. This option will result in a crash unless all objects have the
same number of DAS/SAS components

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib color map}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is a powerfull variable that chooses the colour map applied for all plots. If set to
None (Default) then the self.cmap is used.
As standard I use the color map “jet” from matplotlib. There are a variety of colormaps
available that are very usefull. Beside “jet”, “viridis” is a good choice as it is well
visible under red\sphinxhyphen{}green blindness. Other useful maps are “prism” for high fluctuations
or diverging color maps like “seismic”.
See \sphinxurl{https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html} for a comprehensive
selection. In the code the colormaps are imported so if plot\_func is imported as pf then
self.cmap=pf.cm.viridis sets viridis as the map to use. Internally the colors are chosen
with the “colm” function. The 2d plots require a continuous color map so if something
else is give 2d plots are shown automatically with “jet”. For all of the 1d plots however
I first select a number of colors before each plot. If cmap is a continous map then these
are sampled evenly over the colourmap. Manual iterables of colours
cmap={[}(1,0,0),(0,1,0),(0,0,1),…{]} are also accepted, as are vectors or dataframes that
contain as rows the colors. There must be of course sufficient colors present for
the numbers of lines that will be plotted. So I recommend to provide at least 10 colours
(e.g.\textasciitilde{}your university colors). colours are always given as a, list or tuple with RGA or RGBA
(with the last A beeing the Alpha=transparency. All numbers are between 0 and 1.
If a list/vector/DataFrame is given for the colours they will be used in the order provided.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{plot\PYGZus{}func} \PYG{k}{as} \PYG{n+nn}{pf}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{TA}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test1.hdf5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}open the original project,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{this} \PYG{n}{MUST} \PYG{n}{contain} \PYG{n}{a} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{otherwise} \PYG{n}{this} \PYG{n}{will} \PYG{k}{raise} \PYG{n}{an} \PYG{n}{error}
\end{sphinxVerbatim}

Now open a bunch of other projects to compare against,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{}compare in a single window}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{other\PYGZus{}projects} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{GUI\PYGZus{}open}\PYG{p}{(}\PYG{n}{project\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{file1.hdf5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{file2.hdf5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Compare\PYGZus{}DAC}\PYG{p}{(}\PYG{n}{others} \PYG{o}{=} \PYG{n}{other\PYGZus{}project}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{}comprare in separate windows,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{}the other projects must have the same number of components}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Compare\PYGZus{}DAC}\PYG{p}{(}\PYG{n}{others} \PYG{o}{=} \PYG{n}{other\PYGZus{}project}\PYG{p}{,} \PYG{n}{separate\PYGZus{}plots} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

Compare the DAC to an external spectrum

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ext\PYGZus{}spec} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ascii\PYGZus{}spectrum.dat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{sep} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Compare\PYGZus{}DAC}\PYG{p}{(}\PYG{n}{spectra} \PYG{o}{=} \PYG{n}{ext\PYGZus{}spec}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}compare just the current solution}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Compare\PYGZus{}DAC}\PYG{p}{(}\PYG{n}{spectra} \PYG{o}{=} \PYG{n}{ext\PYGZus{}spec}\PYG{p}{,} \PYG{n}{others} \PYG{o}{=} \PYG{n}{other\PYGZus{}project}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}compare multiple}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Compare\_at\_time() (plot\_func.TA method)@\spxentry{Compare\_at\_time()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.Compare_at_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Compare\_at\_time}}}{\emph{\DUrole{n}{rel\_time}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{other}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{fitted}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{norm\_window}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{time\_width\_percent}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{spectra}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data\_and\_fit}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{cmap}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{print\_click\_position}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{linewidth}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{title}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
This function plots multiple spectra into the same figure at a given rel\_time (timepoints) and
allows for normalization. Very useful to compare the spectra for different solvents or quenchers, or
e.g. different fits. The ta.time\_width\_percent parameter defines if this is a
single time (if time\_width\_percent = 0) or an integrated window.
Only “rel\_time” is a mandatory, the rest can be taken from the original project (ta).

The normalization is realized by giving a norm\_window
at which the intensity in the triggering object is integrated (in ta.Compare\_at\_time(other..)
“ta” is the triggering object. The in each of the other curves the same window is
integrated and the curve scaled by this value. Important to note is that this window
does not need to be in the plot. e.g. the normalization can be done at a different time.

Very often one would like to compare the measured spectra at a certain
time to an external spectrum (e.g. spectro\sphinxhyphen{}electro\sphinxhyphen{}chemistry or steady
state absorption). This can be done by loading a specific spectrum into
a DataFrame and handing this data Frame to the comparision function. The
function can also be used to plot e.g. the measured spectra vs. an
external spectrum without giving any “other” Projects. (very useful for
comparisions).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rel\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list/vector}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Specify the times where to plot, single value or list/vector of values.
For each entry in rel\_time a spectrum is plotted.
If time\_width\_percent=0 (Default) the nearest measured
timepoint is chosen. For other values see parameter “time\_width\_percent”.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{other}} (\sphinxstyleliteralemphasis{\sphinxupquote{TA object}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list of those}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} should be ta.plot\_func objects (loaded or copied) and is what
is plotted against the data use a list {[}ta1,ta2,… {]} or generate this
list using the Gui function. See section {\hyperref[\detokenize{Opening:opening-multiple-files}]{\sphinxcrossref{\DUrole{std,std-ref}{Opening multiple files}}}} in
the documentation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fitted}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} True/False (Default) \sphinxhyphen{} use fitted data instead of raw data.
If True, the fitted datapoints (without interpolation) are used.
This is intended for comparing e.g. different fits

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{norm\_window}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list/vector}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{with 4 floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} norm\_window Give a list/tupel/vector with 4 entries in the order
{[}Start \sphinxhyphen{} time, End \sphinxhyphen{} time, Start \sphinxhyphen{} wavelength, End \sphinxhyphen{} Wavelength{]},
see section  {\hyperref[\detokenize{Comparing:normalization-and-scaling}]{\sphinxcrossref{\DUrole{std,std-ref}{Normalization and Scaling}}}}  in the documentation.
If None (Default) no normalization is done.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{linewidth}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} linewidth to be used for plotting

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time\_width\_percent}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} “rel\_time” and “time\_width\_percent” work together for creating spectral plots at
specific timepoints. For each entry in rel\_time a spectrum is plotted.
If however e.g. time\_width\_percent=10 the region between the timepoint closest
to \(timepoint+0.1xtimepoint´ and :math:\) is averaged and shown
(and the legend adjusted accordingly). If None (Default) is given, the value is
taken from the triggering object (self.time\_width\_percent) This is particularly useful for the densly
sampled region close to t=0. Typically for a logarithmic recorded kinetics, the
timepoints at later times will be further appart than 10 percent of the value,
but this allows to elegantly combine values around time=0 for better statistics.
This averaging is only applied for the plotting function and not for the fits.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{spectra}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If an DataFrame with the wavelength as index is provided, Then the spectra of each column
is plotted into the differential spectra 1\sphinxhyphen{}1 and the column names are used in the legend
Prior scaling is highly suggested. These spectra are not (in general) scaled with the
norm window. (see examples).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_and\_fit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} True or False (Default), choose if for the Fitted plot the raw data of the
other projects is to be plotting in addition to the fitted line. For False (Default)
Only the fit is plotted.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib color map}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is a powerfull variable that chooses the colour map applied for all plots. If set to
None (Default) then the self.cmap is used.
As standard I use the color map “jet” from matplotlib. There are a variety of colormaps
available that are very usefull. Beside “jet”, “viridis” is a good choice as it is well
visible under red\sphinxhyphen{}green blindness. Other useful maps are “prism” for high fluctuations
or diverging color maps like “seismic”.
See \sphinxurl{https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html} for a comprehensive
selection. In the code the colormaps are imported so if plot\_func is imported as pf then
self.cmap=pf.cm.viridis sets viridis as the map to use. Internally the colors are chosen
with the “colm” function. The 2d plots require a continuous color map so if something
else is give 2d plots are shown automatically with “jet”. For all of the 1d plots however
I first select a number of colors before each plot. If cmap is a continous map then these
are sampled evenly over the colourmap. Manual iterables of colours
cmap={[}(1,0,0),(0,1,0),(0,0,1),…{]} are also accepted, as are vectors or dataframes that
contain as rows the colors. There must be of course sufficient colors present for
the numbers of lines that will be plotted. So I recommend to provide at least 10 colours
(e.g.\textasciitilde{}your university colors). colours are always given as a, list or tuple with RGA or RGBA
(with the last A beeing the Alpha=transparency. All numbers are between 0 and 1.
If a list/vector/DataFrame is given for the colours they will be used in the order provided.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{print\_click\_position}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if True then the click position is printed for the spectral plots

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{plot\PYGZus{}func} \PYG{k}{as} \PYG{n+nn}{pf}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{TA}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test1.hdf5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}open the original project}
\end{sphinxVerbatim}

Now open a bunch of other porjects to comare against

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{other\PYGZus{}projects} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{GUI\PYGZus{}open}\PYG{p}{(}\PYG{n}{project\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{file1.SIA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{file2.SIA}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Typical use is compare the raw data without normalization at 1ps and 6ps.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Compare\PYGZus{}at\PYGZus{}time}\PYG{p}{(}\PYG{n}{rel\PYGZus{}time} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{n}{others} \PYG{o}{=} \PYG{n}{other\PYGZus{}project}\PYG{p}{)}
\end{sphinxVerbatim}

Compare the fit withput normalization at 1ps and 6ps.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Compare\PYGZus{}at\PYGZus{}time}\PYG{p}{(}\PYG{n}{rel\PYGZus{}time} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{n}{others} \PYG{o}{=} \PYG{n}{other\PYGZus{}project}\PYG{p}{,} \PYG{n}{fitted} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

Compare with normalization window between 1ps and 2ps and 400nm and 450nm.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{norm\PYGZus{}window}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{400}\PYG{p}{,}\PYG{l+m+mi}{450}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Compare\PYGZus{}at\PYGZus{}time}\PYG{p}{(}\PYG{n}{rel\PYGZus{}time} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{n}{others} \PYG{o}{=} \PYG{n}{other\PYGZus{}project}\PYG{p}{,} \PYG{n}{norm\PYGZus{}window} \PYG{o}{=} \PYG{n}{norm\PYGZus{}window}\PYG{p}{)}
\end{sphinxVerbatim}

Compare the spectrum at 1ps and 6ps with an external spectrum.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ext\PYGZus{}spec} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ascii\PYGZus{}spectrum.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{sep} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Compare\PYGZus{}at\PYGZus{}time}\PYG{p}{(}\PYG{n}{rel\PYGZus{}time} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,} \PYG{n}{spectra} \PYG{o}{=} \PYG{n}{ext\PYGZus{}spec}\PYG{p}{)}
\end{sphinxVerbatim}

Use example \sphinxhyphen{}  Often there are a lot of different measurements to
compare at multiple time. The normlization is performed at the ground state bleach
460 nm and early in time. Then it is better to make a new plot for each
timepoint. The normalization window stays fixed.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{all}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}make some space}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{norm\PYGZus{}window}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.3}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mi}{450}\PYG{p}{,}\PYG{l+m+mi}{470}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}define window in ground state bleach}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{t} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+m+mf}{0.3}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{]}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}iterate over the wavelength}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{ta}\PYG{o}{.}\PYG{n}{Compare\PYGZus{}at\PYGZus{}time}\PYG{p}{(}\PYG{n}{rel\PYGZus{}time} \PYG{o}{=} \PYG{n}{t}\PYG{p}{,} \PYG{n}{others} \PYG{o}{=} \PYG{n}{other\PYGZus{}project}\PYG{p}{,} \PYG{n}{norm\PYGZus{}window} \PYG{o}{=} \PYG{n}{norm\PYGZus{}window}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Compare\_at\_wave() (plot\_func.TA method)@\spxentry{Compare\_at\_wave()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.Compare_at_wave}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Compare\_at\_wave}}}{\emph{\DUrole{n}{rel\_wave}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{other}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{fitted}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{norm\_window}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{width}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cmap}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data\_and\_fit}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{scale\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}symlog\textquotesingle{}}}, \emph{\DUrole{n}{linewidth}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
This function plots multiple kinetics into the same figure at one or
multiple given wavelength (rel\_wave) and  allows for
{\hyperref[\detokenize{Comparing:normalization-and-scaling}]{\sphinxcrossref{\DUrole{std,std-ref}{Normalization and Scaling}}}} Very useful to compare the
kinetics for different quencher concentrations or pump powers,
or e.g. different fits. The parameter width or the general self.wavelength\_bin
which is used if width is None (Default) defines the width of
the spectral window that is integrated and shown.

A normalization window can be given at which all the plotted curves are normalized to.
This window does not have to be in the plotted region. See {\hyperref[\detokenize{Comparing:normalization-and-scaling}]{\sphinxcrossref{\DUrole{std,std-ref}{Normalization and Scaling}}}}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rel\_wave}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list/vector}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Specify the wavelength where to plot the kinetics, single value or
list/vector of values (only mandatory entry) For each entry in
rel\_wave a kinetic is plotted. ‘rel\_wave’ and ‘width’
(in the object called ‘wavelength\_bin’ work together for the creation
of kinetic plots. At each selected wavelength the data between
wavelength+width/2 and wavelength\sphinxhyphen{}width/2 is averaged
for each timepoint

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{other}} (\sphinxstyleliteralemphasis{\sphinxupquote{TA object}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list of those}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} should be ta.plot\_func objects (loaded or copied) and is what
is plotted against the data use a list {[}ta1,ta2,… {]} or generate this
list using the Gui function. See section {\hyperref[\detokenize{Opening:opening-multiple-files}]{\sphinxcrossref{\DUrole{std,std-ref}{Opening multiple files}}}} in
the documentation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fitted}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} True/False (Default) \sphinxhyphen{} use fitted data instead of raw data.
If True, the fitted datapoints (without interpolation) are used.
This is intended for comparing e.g. different fits

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{norm\_window}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list/vector}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{with 4 floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} norm\_window Give a list/tupel/vector with 4 entries in the order
{[}Start \sphinxhyphen{} time, End \sphinxhyphen{} time, Start \sphinxhyphen{} wavelength, End \sphinxhyphen{} Wavelength{]},
see section {\hyperref[\detokenize{Comparing:normalization-and-scaling}]{\sphinxcrossref{\DUrole{std,std-ref}{Normalization and Scaling}}}} in the documentation.
If None (Default) no normalization is done.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{width}} \textendash{} Specify the width above and below the given wavelength that is
integrated as window. If left to (Default) “None” the value from ta is
used.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_and\_fit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} True or False (Default), choose if for the Fitted plot the raw data of the
other projects is to be plotting in addition to the fitted line. For False (Default)
Only the fit is plotted.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{linewidth}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} linewidth to be used for plotting

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib color map}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is a powerfull variable that chooses the colour map applied for all plots. If set to
None (Default) then the self.cmap is used.
As standard I use the color map “jet” from matplotlib. There are a variety of colormaps
available that are very usefull. Beside “jet”, “viridis” is a good choice as it is well
visible under red\sphinxhyphen{}green blindness. Other useful maps are “prism” for high fluctuations
or diverging color maps like “seismic”.
See \sphinxurl{https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html} for a comprehensive
selection. In the code the colormaps are imported so if plot\_func is imported as pf then
self.cmap=pf.cm.viridis sets viridis as the map to use. Internally the colors are chosen
with the “colm” function. The 2d plots require a continuous color map so if something
else is give 2d plots are shown automatically with “jet”. For all of the 1d plots however
I first select a number of colors before each plot. If cmap is a continous map then these
are sampled evenly over the colourmap. Manual iterables of colours
cmap={[}(1,0,0),(0,1,0),(0,0,1),…{]} are also accepted, as are vectors or dataframes that
contain as rows the colors. There must be of course sufficient colors present for
the numbers of lines that will be plotted. So I recommend to provide at least 10 colours
(e.g.\textasciitilde{}your university colors). colours are always given as a, list or tuple with RGA or RGBA
(with the last A beeing the Alpha=transparency. All numbers are between 0 and 1.
If a list/vector/DataFrame is given for the colours they will be used in the order provided.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Scale\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} is a general setting that can influences what time axis will be used for the plots.
“symlog” (linear around zero and logarithmic otherwise) “lin” and “log” are valid options.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{plot\PYGZus{}func} \PYG{k}{as} \PYG{n+nn}{pf}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{TA}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test1.hdf5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}open the original project}
\end{sphinxVerbatim}

Now open a bunch of other projects to compare against

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{other\PYGZus{}projects} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{GUI\PYGZus{}open}\PYG{p}{(}\PYG{n}{project\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{file1.SIA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{file2.SIA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Typical use:
Compare the raw data without normalization at 400 nm and 500 nm

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Compare\PYGZus{}at\PYGZus{}wave}\PYG{p}{(}\PYG{n}{rel\PYGZus{}wave} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{400}\PYG{p}{,} \PYG{l+m+mi}{500}\PYG{p}{]}\PYG{p}{,} \PYG{n}{others} \PYG{o}{=} \PYG{n}{other\PYGZus{}project}\PYG{p}{)}
\end{sphinxVerbatim}

Compare the quality of the fit data without normalization at 400 nm and 500 nm

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Compare\PYGZus{}at\PYGZus{}wave}\PYG{p}{(}\PYG{n}{rel\PYGZus{}wave} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{400}\PYG{p}{,} \PYG{l+m+mi}{500}\PYG{p}{]}\PYG{p}{,} \PYG{n}{others} \PYG{o}{=} \PYG{n}{other\PYGZus{}project}\PYG{p}{,} \PYG{n}{fitted} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

Compare with normalization window between 1ps and 2ps and 400nm and 450nm

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{norm\PYGZus{}window}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{400}\PYG{p}{,}\PYG{l+m+mi}{450}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Compare\PYGZus{}at\PYGZus{}wave}\PYG{p}{(}\PYG{n}{rel\PYGZus{}wave} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{400}\PYG{p}{,} \PYG{l+m+mi}{500}\PYG{p}{]}\PYG{p}{,} \PYG{n}{others} \PYG{o}{=} \PYG{n}{other\PYGZus{}project}\PYG{p}{,} \PYG{n}{norm\PYGZus{}window} \PYG{o}{=} \PYG{n}{norm\PYGZus{}window}\PYG{p}{)}
\end{sphinxVerbatim}

Use example: Often there are a lot of different measurements to
compare at multiple wavelength. The normlization is performed at the ground state bleach
460 nm and early in time. Then it is better to make a new plot for each
wavelength. The normalization window stays fixed.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}make some space}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{norm\PYGZus{}window}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.3}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mi}{450}\PYG{p}{,}\PYG{l+m+mi}{470}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}define window in ground state bleach}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{wave} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+m+mi}{300}\PYG{p}{,}\PYG{l+m+mi}{400}\PYG{p}{,}\PYG{l+m+mi}{500}\PYG{p}{,}\PYG{l+m+mi}{600}\PYG{p}{,}\PYG{l+m+mi}{700}\PYG{p}{]}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{}iterate over the wavelength}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{ta}\PYG{o}{.}\PYG{n}{Compare\PYGZus{}at\PYGZus{}wave}\PYG{p}{(}\PYG{n}{rel\PYGZus{}wave} \PYG{o}{=} \PYG{n}{wave}\PYG{p}{,} \PYG{n}{others} \PYG{o}{=} \PYG{n}{other\PYGZus{}project}\PYG{p}{,} \PYG{n}{norm\PYGZus{}window} \PYG{o}{=} \PYG{n}{norm\PYGZus{}window}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Copy() (plot\_func.TA method)@\spxentry{Copy()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.Copy}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Copy}}}{}{}
returns a deep copy of the object.
\subsubsection*{Examples}

\textgreater{}\textgreater{}\textgreater{}ta=plot\_func.TA(‘testfile.hdf5’) \#open a project
\textgreater{}\textgreater{}\textgreater{}ta1=ta.Copy() \#make a copy for some tests or a differnet fit

\end{fulllineitems}

\index{Cor\_Chirp() (plot\_func.TA method)@\spxentry{Cor\_Chirp()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.Cor_Chirp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Cor\_Chirp}}}{\emph{chirp\_file=None, path=None, shown\_window={[}\sphinxhyphen{}1, 1{]}, fitcoeff=None, max\_points=40, cmap=\textless{}matplotlib.colors.LinearSegmentedColormap object\textgreater{}}}{}
\sphinxstyleemphasis{Cor\_Chirp} is a powerful Function to correct for a different arrival times of
different wavelength (sometimes call chirp).
In general if a file is opened for the first time this function is opening
a plot and allows the user to select a number of points, which are then
approximated with a 4th order polynomial and finally to select a point
that is declared as time zero. The observed window as well as the intensities
and the colour map can be chosen to enable a good correction. Here a fast
iterating colour scheme such as “prism” is often a good choice. In all of the
selections a left click selects, a right click removes the last point and
a middle click (sometime appreviated by clicking left and right together)
finishes the selection. If no middle click exists, the process
automatically ends after max\_points (40 preset).

After the first run the polynom is stored in self.fitcoeff, a new matrix
calculated from self.ds\_ori that is stored as self.ds and a file stored in the
same location as the original data. The second time the function \sphinxstyleemphasis{Cor\_Chirp} is
run the function will find the file and apply the chirp correction automatically.

If one does want to re\sphinxhyphen{}run the chirp correction the function \sphinxstyleemphasis{Man\_Chirp} does
not look for this file, but creates after finishing a new file.

Alternatively the polynom or a filename can be given that load a chirp correction
(e.g. from a different run with the same sample).
The function \sphinxstyleemphasis{Cor\_Chirp} selects in the order:

\# “fitcoeff”
\# “other files”
\# “stored\_file”
\# call Man\_Chirp (clicking by hand)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{chirp\sphinxhyphen{}file}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
If a raw file was read(e.g. “data.SIA”) and the chirp correction was
completed, a file with the attached word “chirp” is created and
stored in the same location. (“data\_chirp.dat”) This file contains
the 5 values of the chirp correction. By selecting such a file
(e.g. from another raw data) a specific chirp is applied. If a
specific name is given with \sphinxstylestrong{chirp\_file} (and optional \sphinxstylestrong{path})
then this file is used.

GUI

The word \sphinxstyleemphasis{‘gui’} can be used instead of a filename to open a gui that
allows the selection of a chrip file


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{path object}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} if path is a string without the operation system dependent separator, it is treated as a relative path,
e.g. data will look from the working directory in the sub director data. Otherwise this has to be a
full path in either strong or path object form.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{shown\_window}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{with two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Defines the window that is shown during chirp correction. If the t=0 is not visible, adjust this parameter
to suit the experiment. If problems arise, I recomment to use Plot\_Raw to check where t=0 is located

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fitcoeff}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{vector}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{5 floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} One can give a vector/list with 5 numbers representing the parameter
of a 4th order polynomial (in the order
\((a4*x^4 + a3*x^3+a2*x^2+a1*x1+a0)\). The chirp parameter are
stored in ta.fitcoeff and can thus be used in other TA objects. This
vector is also stored with the file and automatically applied during
re\sphinxhyphen{}loading of a hdf5\sphinxhyphen{}object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{max\_points}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Default = 40 max numbers of points to use in Gui selection. Useful option in case no middle mouse button
is available. (e.g. touchpad)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib colourmap}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
Colourmap to be used for the chirp correction. While there is a large selection here I recommend to choose
a different map than is used for the normal 2d plotting.

cm.prism (Default) has proofen to be very usefull


\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

In most cases:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{plot\PYGZus{}func} \PYG{k}{as} \PYG{n+nn}{pf}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta} \PYG{o}{=} \PYG{n}{pf}\PYG{o}{.}\PYG{n}{TA}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test1.SIA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}open the original project,}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Cor\PYGZus{}Chirp}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Selecting a specific correction

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZgt{}\PYGZgt{}\PYGZgt{} ta.Cor\PYGZus{}Chirp(‘gui’)
\PYGZgt{}\PYGZgt{}\PYGZgt{} ta.Cor\PYGZus{}Chirp(chirp\PYGZus{}file = \PYGZsq{}older\PYGZus{}data\PYGZus{}chirp.dat\PYGZsq{})
\PYGZgt{}\PYGZgt{}\PYGZgt{} \PYGZsh{}use the coefficients from a different project
\PYGZgt{}\PYGZgt{}\PYGZgt{} ta.Cor\PYGZus{}Chirp(fitcoeff = ta\PYGZus{}old.fitcoeff) \PYGZsh{}use the coefficients from a different project
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Filter\_data() (plot\_func.TA method)@\spxentry{Filter\_data()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.Filter_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Filter\_data}}}{\emph{\DUrole{n}{cut\_bad\_times}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{replace\_bad\_values}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{value}\DUrole{o}{=}\DUrole{default_value}{20}}, \emph{\DUrole{n}{uppervalue}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{lowervalue}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Filteres the data by applying hard replacements. if both replace\_bad\_values and
cut\_bad\_times are false or None, the times above “value” are replaced by zero
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} all values above this (absolute) value are considered to be corrupted. (Default 20) as classically the setup
reports optical DEnsity, an OD of 20 would be far above the typically expected
OD 1e\sphinxhyphen{}3. Pascher instrument software uses a value of 21 to indicate an error.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{uppervalue}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} all values above this number are considered to be corrupted. (Default 20) as classically the setup
reports optical DEnsity, an OD of 20 would be far above the typically expected
OD 1e\sphinxhyphen{}3. Pascher instrument software uses a value of 21 to indicate an error.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lowervalue}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} all values below this number are considered to be corrupted. (Default \sphinxhyphen{}20) as classically the setup
reports optical DEnsity, an OD of \sphinxhyphen{}20 would be far above the typically expected
OD 1e\sphinxhyphen{}3. Pascher instrument software uses a value of 21 to indicate an error.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{replace\_bad\_values}} (\sphinxstyleliteralemphasis{\sphinxupquote{None of float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} values above the treshold are replaced with this value. Ignored of None (Default)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{= bool}} (\sphinxstyleliteralemphasis{\sphinxupquote{cut\_bad\_times}}) \textendash{} True (Default) removes the whole time where this is true

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{optional}} \textendash{} True (Default) removes the whole time where this is true

\end{itemize}

\end{description}\end{quote}

the value is the upper bound. everything
above will be filtered. Standard is to drop the rows(=times) where something went wrong
\subsubsection*{Examples}

typical usage

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{plotfunc} \PYG{k}{as} \PYG{n+nn}{pf}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{=}\PYG{n}{pf}\PYG{o}{.}\PYG{n}{TA}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testfile.SIA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Filter\PYGZus{}data}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Filter\PYGZus{}data}\PYG{p}{(}\PYG{n}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}to filter times with at least one point with OD 1}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Fit\_Global() (plot\_func.TA method)@\spxentry{Fit\_Global()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.Fit_Global}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Fit\_Global}}}{\emph{\DUrole{n}{par}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mod}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{confidence\_level}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{use\_ampgo}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{fit\_chirp}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{fit\_chirp\_iterations}\DUrole{o}{=}\DUrole{default_value}{10}}, \emph{\DUrole{n}{multi\_project}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{unique\_parameter}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{weights}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{dump\_paras}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{filename}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ext\_spectra}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
This function is performing a global fit of the data. As embedded object it uses
the parameter control options of the lmfit project as an essential tool.
(my thanks to Matthew Newville and colleagues for creating this phantastic tool)
{[}M. Newville, T. Stensitzki, D. B. Allen, A. Ingargiola, 2014. DOI: 10.5281/ZENODO.11813.{]}.
The what type of fitting is performed is controlled by setting of the parameter here.
\begin{description}
\item[{The general fitting follows this routine:}] \leavevmode\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
create a copy of the Data\sphinxhyphen{}Matrix self.ds is created with the shaping parameters

\item {} 
Then a Matrix is created that represents the fractional population of each species
(or processes in case of the paral model).
This Matrix contains one entry for each timepoint and represents the kinetic model
based upon the starting parameter. (see below for a description of the models).
This model formation can by done by using a build in or a user supplied function.
(handled in the function “pf.build\_c”)
\sphinxhyphen{}\textgreater{} If an ext\_spectra is provided this its intensity is substacted from the matrix (only for external models)

\item {} 
Then the process/species associated spectra for each of the species is calculated
using the linalg.lstsq algorithm from numpy
(\sphinxurl{https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html})

\item {} 
From the convoluted calculated species concentrations and spectra a calculated matrix
is formed (handled in the function “pf.fill\_int”)

\item {} 
The difference between calculated and measured spectra is calculated, point\sphinxhyphen{}wise squared
and summed together. (function “err\_func” or “err\_func\_multi” if multiple datasets are fitted)

\item {} 
This difference is minimized by iterating 2\sphinxhyphen{}4 with changing parameters using an
optimization algorithm (generally nelder\sphinxhyphen{}mead simplex)

\item {} 
Finally in a last run of 2\sphinxhyphen{}5 the final spectra are calculated (using the “final” flag)
and the optimized parameter, the matrixes
(“A”\sphinxhyphen{}measured, “AC” \sphinxhyphen{} calculated, “AE” \sphinxhyphen{} linear error),
spectra (always called “DAS”) the concentrations (called “c”)
are written in the dictionary “ta.re” together with a few result representations
and other fit outputs. The optimized parameter are also written into ta.par\_fit
(as an parameter object) that can be re\sphinxhyphen{}used as input into further optimization steps.

\end{enumerate}

\end{description}

All mandatory parameters are in general taken from the internal oject (self) The optional parameter control the behaviour of the fitting function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{par}} (\sphinxstyleliteralemphasis{\sphinxupquote{lmfit parameter oject}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Here another parameter object could be given,overwriting the (Default is self.par)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mod}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{function}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Give a extra model selection (Default uses self.mod)
internal modells: ‘paral’,’exponential’,’consecutive’,’full\_consecutive’
see also {\hyperref[\detokenize{plot_func:plot_func.build_c}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{plot\_func.build\_c()}}}}} and {\hyperref[\detokenize{plot_func:plot_func.err_func}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{plot\_func.err\_func()}}}}}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{confidence\_level}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{0.5\sphinxhyphen{}1}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If this is changed from None (Default) to a value between 0.5 and 1 the code will
try to calculate the error of the parameter for the fit. For each parameter that
can vary a separate optimization is     performed, that attempts to find the upper
and lower bound at which the total error of the re\sphinxhyphen{}optimized globally fitted results
reaches the by F\sphinxhyphen{}statistics defined confidence bound. See {\hyperref[\detokenize{plot_func:plot_func.s2_vs_smin2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{plot\_func.s2\_vs\_smin2()}}}}} for details
on how this level is determined. Careful, this option might run for very long time.
Meaning that it typically takes 50 optimization per variable parameter (hard coded limit 200)
The confidence level is to be understood that it defines the e.g. 0.65 * 100\% area that the
parameter with this set of values is within this bounds.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{use\_ampgo}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) is False
Changes the optimizer from a pure Nelder mead to Ampgo with a local Nelder Mead.
For using this powerfull tool all parameter need to have a “min” and a “max” set.
Typically takes 10\sphinxhyphen{}40x longer than a standard optimization, but can due to its
tunneling algorithm more reliably find global minima.
see:https://lmfit.github.io/lmfit\sphinxhyphen{}py/fitting.html for further details

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fit\_chirp}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) is False
a powerful optimization of the chirp parameter. For this to work the data
needs to include timepoints before and after t=0 and one should have reached
a decent fit of most features in the spectrum. We perform an Nelder\sphinxhyphen{}Mead optimisation
of the parameter followed by a Nelder\sphinxhyphen{}Mead optimization of the chirp parameter
as one iteration. After each consecutive optimization it is checked if the total error
improved. If not the fit is ended, if yes the maximum number of iterations
‘fit\_chirp\_iterations’ is performed. Warning, this goes well in many cases,
but can lead to very strange results in others, always carefully check the results.
I recommend to make a copy of the object before runnning a chirp optimization.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fit\_chirp\_iterations}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} maximum number of times the global \sphinxhyphen{} chirp loop is repeated.
Typically this iterations run 2\sphinxhyphen{}5 times, (Default) is 10

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dump\_paras}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) is False, If True creates two files in the working folder, one with the
currently used parameter created at the end of each optimisation step, and one with
the set of parameter that up to now gave the lowest error. Intented to store
the optimisation results if the fit needs to be interrupted
(if e.g. Ampgo simply needs to long to optimize.) useful option if things are slow
this parameter also triggers the writing of fitout to a textfile on disc

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Only used in conjunction with ‘dump\_paras’. The program uses this filename to dump the
parameter to disk

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{multi\_project}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of TA projects}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} This switch is triggering the simultaneous optimisation of multiple datasets.
multi\_project is as (Default) None. it expects an iterable (typically list) with other
TA projects (like ta) that are then optimised with the same parameter.
This means that all projects get the same parameter object for each iteration
of the fit and return their individual error, which is summed linearly.
The “weights” option allows to give each multi\_project a specific weight (number)
that is multiplied to the error. If the weight object has the same number of items
as the multi\_project it is assumed that the triggering object (the embedded project)
has the weight of 1, otherwise the first weight is for the embedded project.
The option ‘unique\_parameter’ takes (a list) of parameter that are not
to be shared between the projects (and that are not optimized either)
The intended use of this is to give e.g. the pump power for multiple experiments to
study non linear behaviour. Returned will be only the parameter set for the optimium
combination of all parameter. Internally, we iterate through the projects and calculate
for each project the error for each iteration. Important to note is that currently this
means that each DAS/SAS is calculated independently! For performing the same calculation
with a single DAS, the Matrixes need to be concatenated before the run and an external
function used to create a combined model. As this is very difficult to implement reliably
For general use (think e.g. different pump wavelength) this has to be done manually.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{unique\_parameter}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of strings}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} only used in conjunction with ‘multi\_project’, it takes (a list) of parameter that
are not to be shared between the projects (and that are not optimized either)
The intended use of this is to give e.g. the pump power for multiple experiments
to study non linear behaviour. (Default) None

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} only used in conjunction with ‘multi\_project’. The “weights” option allows to
give each multi\_project a specific weight (number) that is multiplied to the error.
If the weight object has the same number of items as the ‘multi\_project’ it is assumed
that ta (the embedded project) has the weight of 1, otherwise the first weight is for the
embedded object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ext\_spectra}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) is None, if given substract this spectra from the DataMatrix using the intensity
given in “C(t)” this function will only work for external models. The name of the spectral column
must be same as the name of the column used. If not the spectrum will be ignored. The spectrum will
be interpolated to the spectral points of the model ds before the substraction.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstylestrong{re} (\sphinxstyleemphasis{dict}) \textendash{} the dictionary “re” attached to the object containing all the matrixes and parameter.
The usual keys are:
“A” Shaped measured Matrix
“AC” Shaped calculated Matrix
“AE” Difference between A and AC = linear error
“DAS” DAS or SAS, labeled after the names given in the function (the columns of c) Care must be taken that this mesured intensity is C * DAS, the product. For exponential model the concentrations are normalized
“c” The Concentrations (meaning the evolution of the concentrations over time. Care must be taken that this mesured intensity is C * DAS, the product. For exponential model the concentrations are normalized
“fit\_results\_rates” DataFrame with the fitted rates (and the confidence intervals if calculated)
“fit\_results\_times” DataFrame with the fitted decay times (and the confidence intervals if calculated)
“fit\_output” The Fit object as returned from lmfit. (This is not saved with the project!)
“error” is the S2, meaning AE**2.sum().sum()
“r2”=1\sphinxhyphen{}“error”/((‘A’\sphinxhyphen{}‘A’.mean())**2).sum(), so the residuals scaled with the signal size

\item {} 
\sphinxstylestrong{par\_fit} (\sphinxstyleemphasis{lmfit parameter object}) \textendash{} is written into the object as a lmfit parameter object with the optimized results (that can be use further)

\item {} 
\sphinxstylestrong{fitcoeff} (\sphinxstyleemphasis{list, if chirpfit is done}) \textendash{} The chirp parameter are updated

\item {} 
\sphinxstylestrong{ds} (\sphinxstyleemphasis{DataFrame, if chirpfit is done}) \textendash{} A new ds is calculated form ds\_ori if ChripFit is done

\item {} 
\sphinxstyleemphasis{The rest is mainly printed on screen.}

\end{itemize}


\end{description}\end{quote}
\subsubsection*{Examples}

Non optional:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{=}\PYG{n}{pf}\PYG{o}{.}\PYG{n}{TA}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testfile.SIA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}load data}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{mod}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exponential}\PYG{l+s+s1}{\PYGZsq{}}    \PYG{c+c1}{\PYGZsh{}define model}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{par}\PYG{o}{=}\PYG{n}{lmfit}\PYG{o}{.}\PYG{n}{Parameters}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{}create empty parameter object}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{par}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{n}{vary}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}add at least one parameter to optimize}
\end{sphinxVerbatim}

Trigger simple fit:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Fit\PYGZus{}Global}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Trigger fit with Chrip Fit:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Fit\PYGZus{}Global}\PYG{p}{(}\PYG{n}{fit\PYGZus{}chirp}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

Trigger iterative Chirp fitting with fresh refinement of the Global kinetic parametersfor i in range(5):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{start\PYGZus{}error}\PYG{o}{=}\PYG{n}{ta}\PYG{o}{.}\PYG{n}{re}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{ta}\PYG{o}{.}\PYG{n}{par}\PYG{o}{=}\PYG{n}{ta}\PYG{o}{.}\PYG{n}{par\PYGZus{}fit}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{ta}\PYG{o}{.}\PYG{n}{Fit\PYGZus{}Global}\PYG{p}{(}\PYG{n}{fit\PYGZus{}chirp}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{ta}\PYG{o}{.}\PYG{n}{re}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{error}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{start\PYGZus{}error}\PYG{p}{:}\PYG{k}{break}
\end{sphinxVerbatim}

Trigger fit fit error calculations

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Fit\PYGZus{}Global}\PYG{p}{(}\PYG{n}{confidence\PYGZus{}level}\PYG{o}{=}\PYG{l+m+mf}{0.66}\PYG{p}{)}
\end{sphinxVerbatim}

Trigger fit of multiple projects
\#use the GUI\_open function to open a list of objects (leave empty for using the GUI)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{other\PYGZus{}projects}\PYG{o}{=}\PYG{n}{pf}\PYG{o}{.}\PYG{n}{GUI\PYGZus{}open}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sample\PYGZus{}1.hdf5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sample\PYGZus{}2.hdf5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Fit\PYGZus{}Global}\PYG{p}{(}\PYG{n}{multi\PYGZus{}project}\PYG{o}{=}\PYG{n}{other\PYGZus{}projects}\PYG{p}{)}
\end{sphinxVerbatim}

For more examples please see the complete documentation under {\hyperref[\detokenize{Fitting:fitting-parameter-optimization-and-error-estimation}]{\sphinxcrossref{\DUrole{std,std-ref}{Fitting, Parameter optimization and Error estimation}}}}
or {\hyperref[\detokenize{Fitting:fitting-multiple-measured-files-at-once}]{\sphinxcrossref{\DUrole{std,std-ref}{Fitting multiple measured files at once}}}}

\end{fulllineitems}

\index{Man\_Chirp() (plot\_func.TA method)@\spxentry{Man\_Chirp()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.Man_Chirp}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Man\_Chirp}}}{\emph{shown\_window={[}\sphinxhyphen{}1, 1{]}, path=None, max\_points=40, cmap=\textless{}matplotlib.colors.LinearSegmentedColormap object\textgreater{}}}{}
Triggering of Manuel Fix\_Chirp. usually used when Cor\_Chirp has run aleady.
Alternatively delete the chirp file.

\end{fulllineitems}

\index{Plot\_RAW() (plot\_func.TA method)@\spxentry{Plot\_RAW()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.Plot_RAW}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Plot\_RAW}}}{\emph{\DUrole{n}{plotting}\DUrole{o}{=}\DUrole{default_value}{range(0, 4)}}, \emph{\DUrole{n}{title}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{scale\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}symlog\textquotesingle{}}}, \emph{\DUrole{n}{times}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cmap}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{filename}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{path}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}result\_figures\textquotesingle{}}}, \emph{\DUrole{n}{savetype}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}png\textquotesingle{}}}, \emph{\DUrole{n}{print\_click\_position}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{plot\_second\_as\_energy}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{ds}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
This is a wrapper function that triggers the plotting of various RAW (non fitted) plots.
The shaping parameter are taken from the object and should be defined before.
The parameter in this plot call are to control the general look and features of the plot.
Which plots are printed is defined byt the first command (plotting)
The plots are generated on the fly using self.ds and all the shaping parameter
In all plots the RAW data is plotted as dots and interpolated with lines
(using Savitzky\sphinxhyphen{}Golay window=5, order=3 interpolation). As defined by the internal parameters
at selected time\sphinxhyphen{}points and the kinetics for selected wavelength are shaped by the
object parameter. The SVD is performed using the same shaping parameter and is commonly
used as an orientation for the number of components in the data.
Everything is handed over to ‘plot\_raw’ function that can be used for extended RAW plotting.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plotting}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of integers}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
This parameter determines which figures are plotted
the figures can be called separately with plotting = 1
or with a list of plots (Default) e.g. plotting=range(4) calls plots 0,1,2,3.
The plots have the following numbers:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{-1}
\item {} 
Matrix

\item {} 
Kinetics

\item {} 
Spectra

\item {} 
SVD

\end{enumerate}

The plotting takes all parameter from the “ta” object.


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} title to be used on top of each plot
The (Default) None triggers  self.filename to be used. Setting a specific title as string will.
be used in all plots. To remove the title all together set an empty string with this command title=”” .

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Scale\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} is a general setting that can influences what time axis will be used for the plots.
“symlog” (linear around zero and logarithmic otherwise) “lin” and “log” are valid options.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} are the number of components to be used in the SVD (Default) is 6.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib color map}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is a powerfull variable that chooses the colour map applied for all plots. If set to
None (Default) then the self.cmap is used.
As standard I use the color map “jet” from matplotlib. There are a variety of colormaps
available that are very usefull. Beside “jet”, “viridis” is a good choice as it is well
visible under red\sphinxhyphen{}green blindness. Other useful maps are “prism” for high fluctuations
or diverging color maps like “seismic”.
See \sphinxurl{https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html} for a comprehensive
selection. In the code the colormaps are imported so if plot\_func is imported as pf then
self.cmap=pf.cm.viridis sets viridis as the map to use. Internally the colors are chosen
with the “colm” function. The 2d plots require a continuous color map so if something
else is give 2d plots are shown automatically with “jet”. For all of the 1d plots however
I first select a number of colors before each plot. If cmap is a continous map then these
are sampled evenly over the colourmap. Manual iterables of colours
cmap={[}(1,0,0),(0,1,0),(0,0,1),…{]} are also accepted, as are vectors or dataframes that
contain as rows the colors. There must be of course sufficient colors present for
the numbers of lines that will be plotted. So I recommend to provide at least 10 colours
(e.g.\textasciitilde{}your university colors). colours are always given as a, list or tuple with RGA or RGBA
(with the last A beeing the Alpha=transparency. All numbers are between 0 and 1.
If a list/vector/DataFrame is given for the colours they will be used in the order provided.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} offers to replace the base\sphinxhyphen{}name used for all plots (to e.g.\textasciitilde{}specify what sample was used).
if (Default) None is used, the self.filename is used as a base name. The filename plays only a
role during saving, as does the path and savetype.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{path object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} This defines where the files are saved if the safe\_figures\_to\_folder parameter is True,
quite useful if a lot of data sets are to be printed fast.
If a path is given, this is used. If a string like the (Default) “result\_figures” is given,
then a subfolder of this name will be used (an generated if necessary)
relative to self.path. Use and empty string to use the self.path
If set to None, the location of the plot\_func will be used and
a subfolder with title “result\_figures” be generated here.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{savetype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} matplotlib allows the saving of figures in various formats. (Default) “png”,
typical and recommendable options are “svg” and “pdf”.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{print\_click\_position}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if True then the click position is printed for the spectral plots

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ds}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if None (Default), the program first tests self.ds and if this is not there then self.ds\_ori.
This option was introduced to allow plotting of other matrixes with the same parameter

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

Typically one would call this function empty for an overview. We name the object “ta” so with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{=}\PYG{n}{pf}\PYG{o}{.}\PYG{n}{TA}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testfile.SIA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

This would trigger the plotting of the 4 mayor plots for an overview.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Plot\PYGZus{}RAW}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

This would plot only the kinetics.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Plot\PYGZus{}RAW}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Plot\PYGZus{}RAW}\PYG{p}{(}\PYG{n}{plotting} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Plot\_fit\_output() (plot\_func.TA method)@\spxentry{Plot\_fit\_output()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.Plot_fit_output}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Plot\_fit\_output}}}{\emph{\DUrole{n}{plotting}\DUrole{o}{=}\DUrole{default_value}{range(0, 6)}}, \emph{\DUrole{n}{path}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}result\_figures\textquotesingle{}}}, \emph{\DUrole{n}{savetype}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}png\textquotesingle{}}}, \emph{\DUrole{n}{evaluation\_style}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{title}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{scale\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}symlog\textquotesingle{}}}, \emph{\DUrole{n}{patches}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{filename}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cmap}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{print\_click\_position}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{plot\_second\_as\_energy}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
plots all the fit output figures. The figures can be called separately
or with a list of plots. e.g. range(6) call plots 0\sphinxhyphen{}5 Manual plotting of certain type:

This is a wrapper function that triggers the plotting of all the fitted plots.
The parameter in this plot call are to control the general look and features of the plot.
Which plots are printed is defined by the first command (plotting)
The plots are generated from the fitted Matrixes and as such only will work after a fit was actually
completed (and the “re” dictionary attached to the object.)
In all plots the RAW data is plotted as dots and the fit with lines

Contents of the plots
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{-1}
\item {} 
DAC contains the assigned spectra for each component of the fit. For
a modelling with independent exponential decays this corresponds to
the “Decay Associated Spectra” (DAS). For all other models this
contains the “Species Associated Spectra” (SAS). According to the
model the separate spectra are labeled by time (process) or name, if
a name is associated in the fitting model. The spectra are shown in
the extracted strength in the right pane and normalized in the left.
Extracted strength means that the measured spectral strength is the
intensity (concentration matrix) times this spectral strength. As the
concentration maxima for all DAS are 1 this corresponds to the
spectral strength for the DAS. (please see the documentation for the
fitting algorithm for further details).

\item {} 
summed intensity. All wavelength of the spectral axis are summed for
data and fit. The data is plotted in a number of ways vs linear and
logarithmic axis. This plot is not ment for publication but very
useful to evaluate the quality of a fit.

\item {} 
plot kinetics for selected wavelength (see corresponding RAW plot).

\item {} 
plot spectra at selected times (see corresponding RAW plot).

\item {} 
plots matrix (measured, modelled and error Matrix). The parameter are
the same as used for the corresponding RAW plot with the addition of
“error\_matrix\_amplification” which is a scaling factor multiplied
onto the error matrix. I recommend to play with different “cmap”,
“log\_scale” and “intensity\_scale” to create a pleasing plot.

\item {} 
concentrations. In the progress of the modelling/fitting a matrix is
generated that contains the relative concentrations of the species
modelled. This plot is showing the temporal development of these
species. Further details on how this matrix is generated can be found
in the documentation of the fitting function. The modeled spectra are
the convolution of these vectors (giving the time\sphinxhyphen{}development) and
the DAS/SAS (giving the spectral development).

\end{enumerate}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plotting}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of integers}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
This parameter determines which figures are plotted
the figures can be called separately with plotting = 1
or with a list of plots (Default) e.g. plotting=range(6) calls plots 0,1,2,3,4,5
The plots have the following numbers:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{-1}
\item {} 
DAS or SAS

\item {} 
summed intensity

\item {} 
Kinetics

\item {} 
Spectra

\item {} 
Matrixes

\item {} 
Concentrations (the c\sphinxhyphen{}object)

\end{enumerate}

The plotting takes all parameter from the “ta” object unless otherwise specified


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{path object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} This defines where the files are saved if the safe\_figures\_to\_folder parameter is True,
quite useful if a lot of data sets are to be printed fast.
If a path is given, this is used. If a string like the (Default) “result\_figures” is given,
then a subfolder of this name will be used (an generated if necessary)
relative to self.path. Use and empty string to use the self.path
If set to None, the location of the plot\_func will be used and
a subfolder with title “result\_figures” be generated here

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{savetype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} matplotlib allows the saving of figures in various formats. (Default) “png”,
typical and recommendable options are “svg” and “pdf”.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{evaluation\_style}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} True (Default = False) adds a lot of extra information in the plot

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} “title=None” is in general the filename that was loaded. Setting a
specific title will be used in all plots. To remove the title all
together set an empty string with title=””

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} refers to the time\sphinxhyphen{}axis and takes, “symlog” (Default)(linear around zero and logarithmic otherwise)
and “lin” for linear and  “log” for logarithmic, switching all the time axis to this type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{patches}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If False (Default) the names “measured” “fitted” “difference” will be placed above the images.
If True, then they will be included into the image (denser)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} offers to replace the base\sphinxhyphen{}name used for all plots (to e.g.specify what sample was used).
if (Default) None is used, the self.filename is used as a base name. The filename plays only a
role during saving, as does the path and savetype

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib color map}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is a powerfull variable that chooses the colour map applied for all plots. If set to
None (Default) then the self.cmap is used.
As standard I use the color map “jet” from matplotlib. There are a variety of colormaps
available that are very usefull. Beside “jet”, “viridis” is a good choice as it is well
visible under red\sphinxhyphen{}green blindness. Other useful maps are “prism” for high fluctuations
or diverging color maps like “seismic”.
See \sphinxurl{https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html} for a comprehensive
selection. In the code the colormaps are imported so if plot\_func is imported as pf then
self.cmap=pf.cm.viridis sets viridis as the map to use. Internally the colors are chosen
with the “colm” function. The 2d plots require a continuous color map so if something
else is give 2d plots are shown automatically with “jet”. For all of the 1d plots however
I first select a number of colors before each plot. If cmap is a continous map then these
are sampled evenly over the colourmap. Manual iterables of colours
cmap={[}(1,0,0),(0,1,0),(0,0,1),…{]} are also accepted, as are vectors or dataframes that
contain as rows the colors. There must be of course sufficient colors present for
the numbers of lines that will be plotted. So I recommend to provide at least 10 colours
(e.g.your university colors). colours are always given as a, list or tuple with RGA or RGBA
(with the last A beeing the Alpha=transparency. All numbers are between 0 and 1.
If a list/vector/DataFrame is given for the colours they will be used in the order provided.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{print\_click\_position}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if True then the click position is printed for the spectral plots

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

Typically one would call this function empty for an overview:
After the minimum fit

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{=}\PYG{n}{pf}\PYG{o}{.}\PYG{n}{TA}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testfile.SIA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{par}\PYG{o}{=}\PYG{n}{lmfit}\PYG{o}{.}\PYG{n}{Parameters}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{par}\PYG{o}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{value}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{n}{vary}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Fit\PYGZus{}Global}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

One usually plots the an overview

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Plot\PYGZus{}fit\PYGZus{}output}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Plot\PYGZus{}fit\PYGZus{}output}\PYG{p}{(}\PYG{n}{plotting}\PYG{o}{=}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}is the same as before}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Plot\PYGZus{}fit\PYGZus{}output}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}would plot only the kinetics}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Plot\PYGZus{}fit\PYGZus{}output}\PYG{p}{(}\PYG{n}{plotting} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}would plot only the kinetics}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Save\_Plots() (plot\_func.TA method)@\spxentry{Save\_Plots()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.Save_Plots}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Save\_Plots}}}{\emph{\DUrole{n}{path}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}result\_figures\textquotesingle{}}}, \emph{\DUrole{n}{savetype}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{title}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{filename}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{scale\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}symlog\textquotesingle{}}}, \emph{\DUrole{n}{patches}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{cmap}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Convenience function that sets save\_plots\_to\_folder temporarily to true and replots everything
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{path}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) None, if left on None, then a folder “result\_figures” is created in the folder
of the data (self.path)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{savetype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} matplotlib allows the saving of figures in various formats. (Default) “png”,
typical and recommendable options are “svg” and “pdf”.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) None, Use this title on all plots. if None, use self.filename

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) None, Base name for all plots. If None, then self.filename will be used

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} “symlog” (Default), “linear”, “log” time axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{patches}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} For true use white patches to label things in the 2d matrixes, to safe
space for publication

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib color map}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is a powerfull variable that chooses the colour map applied for all plots. If set to
None (Default) then the self.cmap is used.
As standard I use the color map “jet” from matplotlib. There are a variety of colormaps
available that are very usefull. Beside “jet”, “viridis” is a good choice as it is well
visible under red\sphinxhyphen{}green blindness. Other useful maps are “prism” for high fluctuations
or diverging color maps like “seismic”.
See \sphinxurl{https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html} for a comprehensive
selection. In the code the colormaps are imported so if plot\_func is imported as pf then
self.cmap=pf.cm.viridis sets viridis as the map to use. Internally the colors are chosen
with the “colm” function. The 2d plots require a continuous color map so if something
else is give 2d plots are shown automatically with “jet”. For all of the 1d plots however
I first select a number of colors before each plot. If cmap is a continous map then these
are sampled evenly over the colourmap. Manual iterables of colours
cmap={[}(1,0,0),(0,1,0),(0,0,1),…{]} are also accepted, as are vectors or dataframes that
contain as rows the colors. There must be of course sufficient colors present for
the numbers of lines that will be plotted. So I recommend to provide at least 10 colours
(e.g.\textasciitilde{}your university colors). colours are always given as a, list or tuple with RGA or RGBA
(with the last A beeing the Alpha=transparency. All numbers are between 0 and 1.
If a list/vector/DataFrame is given for the colours they will be used in the order provided.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Save\PYGZus{}Plots}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Save\PYGZus{}Plots}\PYG{p}{(}\PYG{n}{patches} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Save\_Powerpoint() (plot\_func.TA method)@\spxentry{Save\_Powerpoint()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.Save_Powerpoint}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Save\_Powerpoint}}}{\emph{\DUrole{n}{save\_RAW}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{save\_Fit}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{filename}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{path}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}result\_figures\textquotesingle{}}}, \emph{\DUrole{n}{scale\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}symlog\textquotesingle{}}}, \emph{\DUrole{n}{title}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{patches}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{cmap}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{savetype}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}pptx\textquotesingle{}}}}{}
This function creates two power point slides. On the first it summarizes the RAW plots and on
the second (if existent) it summarizes the fitted results
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{save\_RAW}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) True then the first slide with the RAW data is created

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{save\_Fit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) True then the second slide with the Fitted data is created

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{path}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) None, if left on None, then a folder “result\_figures” is created in the folder
of the data (self.path)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{savetype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} triggers the additional creation of a composite file in this format.
matplotlib allows the saving of figures in various formats. (Default) “png”,
typical and recommendable options are “svg” and “pdf”.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) None, Use this title on all plots. if None, use self.filename

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) None, Base name for all plots. If None, then self.filename will be used

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} ‘symlog’ (Default), ‘linear’, ‘log’ time axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{patches}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} For true use white patches to label things in the 2d matrixes, to safe
space for publication

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib color map}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is a powerfull variable that chooses the colour map applied for all plots. If set to
None (Default) then the self.cmap is used.
As standard I use the color map “jet” from matplotlib. There are a variety of colormaps
available that are very usefull. Beside “jet”, “viridis” is a good choice as it is well
visible under red\sphinxhyphen{}green blindness. Other useful maps are “prism” for high fluctuations
or diverging color maps like “seismic”.
See \sphinxurl{https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html} for a comprehensive
selection. In the code the colormaps are imported so if plot\_func is imported as pf then
self.cmap=pf.cm.viridis sets viridis as the map to use. Internally the colors are chosen
with the “colm” function. The 2d plots require a continuous color map so if something
else is give 2d plots are shown automatically with “jet”. For all of the 1d plots however
I first select a number of colors before each plot. If cmap is a continous map then these
are sampled evenly over the colourmap. Manual iterables of colours
cmap={[}(1,0,0),(0,1,0),(0,0,1),…{]} are also accepted, as are vectors or dataframes that
contain as rows the colors. There must be of course sufficient colors present for
the numbers of lines that will be plotted. So I recommend to provide at least 10 colours
(e.g.\textasciitilde{}your university colors). colours are always given as a, list or tuple with RGA or RGBA
(with the last A beeing the Alpha=transparency. All numbers are between 0 and 1.
If a list/vector/DataFrame is given for the colours they will be used in the order provided.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Save\PYGZus{}Powerpoint}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Save\PYGZus{}Powerpoint}\PYG{p}{(}\PYG{n}{patches} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Save\_data() (plot\_func.TA method)@\spxentry{Save\_data()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.Save_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Save\_data}}}{\emph{\DUrole{n}{save\_RAW}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{save\_Fit}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{save\_slices}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{save\_binned}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{filename}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{save\_fit\_results}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{path}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}Data\_export\textquotesingle{}}}, \emph{\DUrole{n}{sep}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textbackslash{}t\textquotesingle{}}}}{}
handy function to save the data on disk as dat files.
The RAW labeled files contain the chirp corrected values (self.ds)

the save\_slices switch turns on the dump of the separate sliced figures (time and spectral)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{save\_binned}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is also the re\sphinxhyphen{}binned matrix to be saved.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{save\_slices}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} save the kinetics and spectra from the fitted data (with the fits)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sep}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} what symbol is used to separate different number. (typical either ‘tab’ or comma

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{save\_RAW}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) True then the first slide with the RAW data is created

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{save\_Fit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) True then the second slide with the Fitted data is created

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{path}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) None, if left on None, then a folder “result\_figures” is created in the folder
of the data (self.path)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{save\_fit\_results}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if True (Default)  a neatly formated file with the fit results is created and stored with the data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) None, Base name for all plots. If None, then self.filename will be used

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Save\PYGZus{}Data}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{Save\_project() (plot\_func.TA method)@\spxentry{Save\_project()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.Save_project}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Save\_project}}}{\emph{\DUrole{n}{filename}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{path}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
function to dump all the parameter of an analysis into an hdf5 file.
This file contains the ds\_ori and all the parameter, including fitting parameter
and results.
One limitation is the fitting model. If the model is build in, so the model is
‘exponential’ or ‘parallel’ then the safing works. If an external model is used then the
dostring of the external function is stored, but not the function itself.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{path}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) None, if left on None, then a folder “Data” is created in the folder
of the project (self.path)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) None, Base name for all plots. If None, then self.filename will be used

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{Save\PYGZus{}project}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{\_\_init\_\_() (plot\_func.TA method)@\spxentry{\_\_init\_\_()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{n}{path}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{sep}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textbackslash{}t\textquotesingle{}}}, \emph{\DUrole{n}{decimal}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}.\textquotesingle{}}}, \emph{\DUrole{n}{index\_is\_energy}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{transpose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sort\_indexes}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{divide\_times\_by}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{shift\_times\_by}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{external\_time}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{external\_wave}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data\_type}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{units}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Function that opens and imports data into an TA object
it is designed to open combined files that contain both the wavelength and the time. (e.g. SIA files as recorded by Pascher instruments software) or hdf5 projects saved by this software
There are however a lot of additional options to open other ascii type files and adapt their format internally
Attention times with Nan will be completely removed during the import
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} expects a filename in string form for opening a single file. alternatively ‘gui’ can be set as
filename, then a TKinter gui is opened for select.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{path object}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} if path is a string without the operation system dependent separator, it is treated as a relative path,
e.g. data will look from the working directory in the sub director data. Otherwise this has to be a
full path in either strong or path object form.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sep}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} is the separator between different numbers, typical are tap (Backslash t) (Default) ,one or
multiple white spaces ‘backslash s+’ or comma ‘,’.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{decimal}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} sets the ascii symbol that is used for the decimal sign. In most countries this is ‘.’(Default)
but it can be ‘,’ in countries like Sweden or Germany

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index\_is\_energy}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} switches if the wavelength is given in nm (Default) or in eV (if True), currently everything
is handled as wavelength in nm internally

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{None}}) \textendash{} data\_type is the string that represents the intensity measurements. Usually this contains if absolute
of differential data. This is used for the color intensity in the 2d plots and the y\sphinxhyphen{}axis for the 1d plots

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{units}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} this is used to identify the units on the energy axis and to label the slices, recognized is ‘nm’, ‘eV’ and ‘keV’
but if another unit like ‘cm\textasciicircum{}\sphinxhyphen{}1’ is used it will state energy in ‘cm\textasciicircum{}\sphinxhyphen{}1’. Pleas observe that if you use the index\_is\_energy
switch the program tries to convert this energy into wavelength.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{transpose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} if this switch is False (Default) the wavelength are the columns and the rows the times.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sort\_indexes}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} For False (Default) I assume that the times and energies are already in a rising order.
with this switch, both are sorted again.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{divide\_times\_by}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} here a number can be given that scales the time by an arbitary factor. This is actually dividing
the times by this value. Alternatively there is the variable self.baseunit. The latter only affects
what is written on the axis, while this value is actually used to scale the times. False (Default)
ignores this

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{shift\_times\_by}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} This a value by which the time axis is shifted during import. This is a useful option of e.g.
the recording software does not compensate for t0 and the data is always shifted.
None (Default) ignores this setting

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_type}} \textendash{} this is the datatype and effectively the unit put on the intensity axis
(Default)’differential Absorption in \$mathregular\{Delta OD\}\$

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{external\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Here a filename extension (string) can be given that contains the time vector.
The file is assumed to be at the same path as the data and to contain a single
type of separated data without header. It also assumes that this is the ending
for the file. The filename itself is taken from the filename.
e.g. if samp1.txt is the filename and external\_time=’.tid’ the program searches
samp1.tid for the times. The transpose setting is applied and sets where the times are
to be inserted (row or column indexes)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{external\_wave}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Here a filename extension (string) can be given that contains the wavelength vector.
The file is assumed to be at the same path as the data and to contain a single type
of separated data without header. This is the ending for the file. The filename itself
is taken from the filename. e.g. if samp1.txt is the filename and external\_wave=’.wav’
then the program searches samp1.wav for the wavelength. The transpose setting is applied
and sets where the wavelength are to be inserted (columns or row indexes)

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
A TA object with all parameter initialized

\end{description}\end{quote}
\subsubsection*{Examples}

Typical useage:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{plot\PYGZus{}func} \PYG{k}{as} \PYG{n+nn}{pf} \PYG{c+c1}{\PYGZsh{}import the module and give it a shorter name}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{=}\PYG{n}{pf}\PYG{o}{.}\PYG{n}{TA}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gui}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}use a GUI to open}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{=}\PYG{n}{pf}\PYG{o}{.}\PYG{n}{TA}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sample\PYGZus{}1.SIA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}use a filename in the same folder}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{=}\PYG{n}{pf}\PYG{o}{.}\PYG{n}{TA}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sample\PYGZus{}1.hdf5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{path}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}use a filename in the folder \PYGZsq{}Data\PYGZsq{}}
\end{sphinxVerbatim}

Opening a list of files with external time vector (of the same name) so it looks for a data
file “fite1.txt” and a file with the time information “file1.tid”

\textgreater{}\textgreater{}\textgreater{}ta=pf.TA(‘file1.txt’, external\_time = ‘tid’)

\end{fulllineitems}

\index{\_\_make\_standard\_parameter() (plot\_func.TA method)@\spxentry{\_\_make\_standard\_parameter()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.__make_standard_parameter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_make\_standard\_parameter}}}{}{}
function that sets the standard parameter. The function takes no input, but we use this docstring to explain the parameter.
\begin{quote}
\begin{description}
\item[{log\_scale}] \leavevmode{[}bool, optional{]}
If False (Default), The 2D plots (Matrix) is plotted with a pseudo logarithmic intensity scale.
This usually does not give good results unless the intensity scale is symmetric

\item[{self.cmap}] \leavevmode{[}matplotlib.cm{]}
(Default)  standard\_map \sphinxhyphen{} global parameter
cmap is a powerfull variable that chooses the colour map applied for all plots. If set to
None (Default) then the self.cmap is used.
As standard I use the color map “jet” from matplotlib. There are a variety of colormaps
available that are very usefull. Beside “jet”, “viridis” is a good choice as it is well
visible under red\sphinxhyphen{}green blindness. Other useful maps are “prism” for high fluctuations
or diverging color maps like “seismic”.
See \sphinxurl{https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html} for a comprehensive
selection. In the code the colormaps are imported so if plot\_func is imported as pf then
self.cmap=pf.cm.viridis sets viridis as the map to use. Internally the colors are chosen
with the “colm” function. The 2d plots require a continuous color map so if something
else is give 2d plots are shown automatically with “jet”. For all of the 1d plots however
I first select a number of colors before each plot. If cmap is a continous map then these
are sampled evenly over the colourmap. Manual iterables of colours
cmap={[}(1,0,0),(0,1,0),(0,0,1),…{]} are also accepted, as are vectors or dataframes that
contain as rows the colors. There must be of course sufficient colors present for
the numbers of lines that will be plotted. So I recommend to provide at least 10 colours
(e.g.\textasciitilde{}your university colors). colours are always given as a, list or tuple with RGA or RGBA
(with the last A beeing the Alpha=transparency. All numbers are between 0 and 1.
If a list/vector/DataFrame is given for the colours they will be used in the order provided.

\item[{self.lintresh}] \leavevmode{[}float{]}
The pseudo logratihmic range “symlog” is used for most time axis. Symlog plots a range around
time zero linear and beyond this linear treshold ‘lintresh’ on a logarithmic scale. (Default) 0.3

\item[{self.log\_fit  :}] \leavevmode
(Default)  False

Transfer all the time\sphinxhyphen{}fitting parameters into log\sphinxhyphen{}space before the fit

\item[{self.ignore\_time\_region}] \leavevmode{[}None or list (of two floats or of lists){]}
(Default)  None
cut set a time range with a low and high limit from the fits. (Default) None nothing happens
The region will be removed during the fitting process (and will be missing in the fit\sphinxhyphen{}result
plots)

Usage single region: {[}lower region limit,upper region limit{]}

use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item[{self.error\_matrix\_amplification  :}] \leavevmode
(Default)  10

\item[{self.rel\_wave}] \leavevmode{[}float or list (of floats){]}
(Default)  np.arange(300,1000,100)

‘rel\_wave’ and ‘width’ (in the object called ‘wavelength\_bin’ work together for the creation
of kinetic plots. When plotting kinetic spectra one line will be plotted for each entrance
in the list/vector rel\_wave. During object generation the vector np.arange(300,1000,100)
is set as standard. Another typical using style would be to define a list of interesting
wavelength at which a kinetic development is to be plotted. At each selected wavelength
the data between wavelength+ta.wavelength\_bin and wavelength\sphinxhyphen{}ta.wavelength\_bin is averaged
for each timepoint returned

\item[{self.rel\_time}] \leavevmode{[}float or list/vector (of floats){]}
(Default)  {[}0.2,0.3,0.5,1,3,10,30,100,300,1000,3000,9000{]}

For each entry in rel\_time a spectrum is plotted. If time\_width\_percent=0 (Default) the
nearest measured timepoint is chosen. For other values see ‘time\_width\_percent’

\item[{self.time\_width\_percent}] \leavevmode{[}float{]}
(Default)  0 “rel\_time” and “time\_width\_percent” work together for
creating spectral plots at specific timepoints. For each entry
in rel\_time a spectrum is plotted. If however e.g. time\_width\_percent=10
the region between the timepoint closest to the  1.1 x timepoint
and 0.9 x timepoint is averaged and shown (and the legend adjusted accordingly).
This is particularly useful for the densly
sampled region close to t=0. Typically for a logarithmic recorded kinetics, the
timepoints at later times will be further appart than 10 percent of the value,
but this allows to elegantly combine values around time=0 for better statistics.
This averaging is only applied for the plotting function and not for the fits.

\item[{self.baseunit}] \leavevmode{[}str{]}
(Default)  ‘ps’

baseunit is a neat way to change the unit on the time axis of the plots. (Default) ‘ps’, but they
can be frames or something similarly. This is changing only the label of the axis.
During the import there is the option to divide the numbers by a factor.
I have also used frames or fs as units. Important is that all time units will be labeled with
this unit.

\item[{self.mod  :}] \leavevmode
(Default)  ‘exponential’

This is the default fitting function, in general this is discussed in the fitting section

\item[{self.scattercut}] \leavevmode{[}None or iterable (of floats or other iterable, always pairs!){]}
(Default)  None

intented to “cut” one or multiple scatter regions. (if (Default) None nothing
happens) If it is set the spectral region between the limits is set to zero.
Usage single region: {[}lower region limit,upper region limit{]},
use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item[{self.bordercut}] \leavevmode{[}None or iterable (with two floats){]}
(Default)  None

cut spectra at the low and high wavelength limit. (Default) None
uses the limits of measurement

\item[{self.time\_bin}] \leavevmode{[}None or int{]}
(Default)  None
is dividing the points on the time\sphinxhyphen{}axis in even bins and averages the found values in between.
This is a hard approach that also affects the fits. I do recommend to use this carefully,
it is most useful for modulated data. A better choice for transient absorption that only
affects the kinetics is ‘time\_width\_percent’

\item[{self.timelimits}] \leavevmode{[}None or list (of 2 floats){]}
(Default)  None

cut times at the low and high time limit. (Default) None uses the limits of measurement
Important: If either the background or the chirp is to be fit this must include the
time before zero! Useful: It is useful to work on different regions, starting with
the longest (then use the ta.Backgound function prior to fit) and expand from there

\item[{data\_type}] \leavevmode{[}str{]}
this is the datatype and effectively the unit put on the intensity axis
(Default)’differential Absorption in \$mathregular\{Delta OD\}\$

\item[{self.wave\_nm\_bin}] \leavevmode{[}None or float{]}
(Default)  None

rebins the original data into even intervals. If set to None the original data will be used.
If set to a width (e.g. 2nm), the wavelength axis will be divided into steps of this size
and the mean of all measurements in the interval is taken. The re\sphinxhyphen{}binning stops as soon as
the measured stepsize is wider than given here, then the original bins are used.
This function is particularly useful for spectrometer with non\sphinxhyphen{}linear dispersion,
like a prism in the infrared.

\item[{self.wavelength\_bin}] \leavevmode{[}float, optional{]}
(Default)  10nm the width used in kinetics, see below

\item[{self.intensity\_range}] \leavevmode{[}None, float or list {[}of two floats{]}{]}
(Default)  None \sphinxhyphen{} intensity\_range is a general switch that governs what intensity range the plots show.
For the 1d plots this is the y\sphinxhyphen{}axis for the 2d\sphinxhyphen{}plots this is the colour scale.
This parameter recognizes three settings. If set to “None” (Default) this uses the minimum and
maximum of the data. A single value like in the example below and the intended use is the symmetric
scale while a list with two entries an assymmetric scale e.g.
intensity\_range=3e\sphinxhyphen{}3 is converted into intensity\_range={[}\sphinxhyphen{}3e\sphinxhyphen{}3,3e\sphinxhyphen{}3{]}

\item[{self.ds\_ori.columns.name  :}] \leavevmode
(Default)  ‘Wavelength in nm’

This is the general energy axis. here we define it with the unit. Change this to energy for use in e.g x\sphinxhyphen{}ray science

\item[{self.ds\_ori.index.name :}] \leavevmode
Standard ‘Time in \%s’ \% self.baseunit

\item[{self.data\_type: str (optional)}] \leavevmode
self.data\_type=’diff. Absorption

\end{description}
\end{quote}
\begin{description}
\item[{in \$mathregular\{Delta OD\}\$’}] \leavevmode\begin{description}
\item[{self.fitcoeff}] \leavevmode{[}list (5 floats){]}
chirp correction polynom

\item[{self.chirp\_file}] \leavevmode{[}str{]}
if there is a file withthe right name write it here, otherwise None

\item[{self.figure\_path}] \leavevmode{[}str{]}
Path for saving figures, if set

\item[{self.save\_figures\_to\_folder}] \leavevmode{[}bool{]}
if True all figures are automatically saved when any plotfunction is called

\end{description}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{bordercut}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{350}\PYG{p}{,}\PYG{l+m+mi}{1200}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{}remove all data outside this limit}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{scattercut}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{522}\PYG{p}{,}\PYG{l+m+mi}{605}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{}set data inside this limit to zero}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{timelimits}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{l+m+mi}{5000}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{}remove all data outside this limit}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{wave\PYGZus{}nm\PYGZus{}bin}\PYG{o}{=}\PYG{l+m+mi}{5}  \PYG{c+c1}{\PYGZsh{}rebin the data to this width}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{intensity\PYGZus{}range}\PYG{o}{=}\PYG{l+m+mf}{3e\PYGZhy{}3}  \PYG{c+c1}{\PYGZsh{}equivalent to [\PYGZhy{}3e\PYGZhy{}3,3e\PYGZhy{}3]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{intensity\PYGZus{}range}\PYG{o}{=}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{,}\PYG{l+m+mf}{3e\PYGZhy{}3}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{}intensity that is plotted in 2d plot and y\PYGZhy{}axis in 1d plots}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{cmap}\PYG{o}{=}\PYG{n}{matplotlib}\PYG{o}{.}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{prism}  \PYG{c+c1}{\PYGZsh{}choose different colour map}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{ignore\PYGZus{}time\PYGZus{}region}\PYG{o}{=}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{l+m+mf}{0.1}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}ignore \PYGZhy{}0.1ps to 0.1ps}
\end{sphinxVerbatim}

\end{description}

\end{fulllineitems}

\index{\_\_read\_ascii\_data() (plot\_func.TA method)@\spxentry{\_\_read\_ascii\_data()}\spxextra{plot\_func.TA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.TA.__read_ascii_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_read\_ascii\_data}}}{\emph{\DUrole{n}{sep}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textbackslash{}t\textquotesingle{}}}, \emph{\DUrole{n}{decimal}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}.\textquotesingle{}}}, \emph{\DUrole{n}{index\_is\_energy}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{transpose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sort\_indexes}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{divide\_times\_by}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{shift\_times\_by}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{external\_time}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{external\_wave}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{correct\_ascii\_errors}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{data\_type}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{units}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Fancy function that handles the import of pure ascii files.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sep}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} is the separator between different numbers, typical are tap (Backslash t) (Default) ,one or
multiple white spaces ‘backslash s+’ or comma ‘,’.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{decimal}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} sets the ascii symbol that is used for the decimal sign. In most countries this is ‘.’(Default)
but it can be ‘,’ in countries like Sweden or Germany

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index\_is\_energy}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} switches if the wavelength is given in nm (Default) or in eV (if True), currently everything
is handled as wavelength in nm internally

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} data\_type is the string that represents the intensity measurements. Usually this contains if absolute
of differential data. This is used for the color intensity in the 2d plots and the y\sphinxhyphen{}axis for the 1d plots

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{units}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} this is used to identify the units on the energy axis and to label the slices, recognized is ‘nm’, ‘eV’ and ‘keV’
but if another unit like ‘cm\textasciicircum{}\sphinxhyphen{}1’ is used it will state energy in ‘cm\textasciicircum{}\sphinxhyphen{}1’. Pleas observe that if you use the index\_is\_energy
switch the program tries to convert this energy into wavelength.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{transpose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} if this switch is False (Default) the wavelength are the columns and the rows the times.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sort\_indexes}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} For False (Default) I assume that the times and energies are already in a rising order.
with this switch, both are sorted again.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{divide\_times\_by}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} here a number can be given that scales the time by an arbitary factor. This is actually dividing
the times by this value. Alternatively there is the variable self.baseunit. The latter only affects
what is written on the axis, while this value is actually used to scale the times. False (Default)
ignores this

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{shift\_times\_by}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} This a value by which the time axis is shifted during import. This is a useful option of e.g.
the recording software does not compensate for t0 and the data is always shifted.
None (Default) ignores this setting

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{external\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Here a filename extension (string) can be given that contains the time vector.
The file is assumed to be at the same path as the data and to contain a single
type of separated data without header. It also assumes that this is the ending
for the file. The filename itself is taken from the filename.
e.g. if samp1.txt is the filename and external\_time=’.tid’ the program searches
samp1.tid for the times. The transpose setting is applied and sets where the times are
to be inserted (row or column indexes)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{external\_wave}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Here a filename extension (string) can be given that contains the wavelength vector.
The file is assumed to be at the same path as the data and to contain a single type
of separated data without header. This is the ending for the file. The filename itself
is taken from the filename. e.g. if samp1.txt is the filename and external\_wave=’.wav’
then the program searches samp1.wav for the wavelength. The transpose setting is applied
and sets where the wavelength are to be inserted (columns or row indexes)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{correct\_ascii\_errors}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} If True (Default) then the code tries to catch some stuff like double minus signs and double dots

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\phantomsection\label{\detokenize{plot_func:module-plot_func}}\index{module@\spxentry{module}!plot\_func@\spxentry{plot\_func}}\index{plot\_func@\spxentry{plot\_func}!module@\spxentry{module}}\index{Frame\_golay() (in module plot\_func)@\spxentry{Frame\_golay()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.Frame_golay}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{Frame\_golay}}}{\emph{\DUrole{n}{df}}, \emph{\DUrole{n}{window}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{order}\DUrole{o}{=}\DUrole{default_value}{2}}, \emph{\DUrole{n}{transpose}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Convenience method that returns the Golay smoothed data for each column (DataFrame) or the series
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{df}} (\sphinxstyleliteralemphasis{\sphinxupquote{pandas.DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{pandas.Series}}) \textendash{} the DataFrame that has to be interpolated

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{window\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 5(Default) an integer that indicates how many units are to be interpolated

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 2 (Default) an integer that indicates what orderpolynoninal is to be used to interpolate the points.
order=1 effectively turns this into a floating average

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{transpose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} in which orientation is the interpolation to be done. Default is in within the column (usually timepoints)

\end{itemize}

\item[{Returns}] \leavevmode
DataFrame or Series with the interpolation applied

\item[{Return type}] \leavevmode
pandas.DataFrame or pandas.Series

\end{description}\end{quote}

\end{fulllineitems}

\index{GUI\_open() (in module plot\_func)@\spxentry{GUI\_open()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.GUI_open}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{GUI\_open}}}{\emph{\DUrole{n}{project\_list}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{path}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{filename\_part}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{fileending}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}hdf5\textquotesingle{}}}, \emph{\DUrole{n}{sep}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textbackslash{}t\textquotesingle{}}}, \emph{\DUrole{n}{decimal}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}.\textquotesingle{}}}, \emph{\DUrole{n}{index\_is\_energy}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{transpose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sort\_indexes}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{divide\_times\_by}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{shift\_times\_by}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{external\_time}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{external\_wave}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data\_type}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{units}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
This Function
1. opens a gui and allows the selection of multiple saved projects, which are returned as a list
2. if given a list of project names opens them
3. if given the word ‘all’, opens all files in a given folder
The general behavior is selected by the first parameter (project\_list)

it is designed to open combined files that contain both the wavelength and the time. (e.g. SIA files as recorded by Pascher instruments software) or hdf5 projects saved by this software
There are however a lot of additional options to open other ascii type files and adapt their format internally
Important, as default the parameter “fileending” selects hdf5 files only, which are used as project files (see {\hyperref[\detokenize{plot_func:plot_func.TA.Save_project}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{plot\_func.TA.Save\_project()}}}}})
for opening of other files the fileending parameter needs to be changed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{project\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of str}}\sphinxstyleliteralemphasis{\sphinxupquote{) or }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}all\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Give a list of filenames that will be opened and returned as a list of objects
if the project list is ‘all’ then all files in the folder specified in path. The parameter “filename\_part”
and “fileending” can be used to specify this selection

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{path object}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} if path is a string without the operation system dependent separator, it is treated as a relative path,
e.g. data will look from the working directory in the sub director data. Otherwise this has to be a
full path in either strong or path object form.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename\_part}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} This parameter is only used for the option ‘all’, the (Default) None means do nothing. if a string is given then only
files that start with this string will be read.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fileending}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} this string is used to select the filetype that is suppose to open. For the GUI, only these files will be shown,
with the option ‘all’ this selects the files that will be read in the folder, ‘hdf5’ (Default)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sep}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} is the separator between different numbers, typical are tap ‘   ‘ (Default) ,one or
multiple white spaces ‘s+’ or comma ‘,’.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{decimal}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} sets the ascii symbol that is used for the decimal sign. In most countries this is ‘.’(Default)
but it can be ‘,’ in countries like Sweden or Germany

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index\_is\_energy}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} switches if the wavelength is given in nm (Default) or in eV (if True), currently everything
is handled as wavelength in nm internally

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{transpose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} if this switch is False (Default) the wavelength are the columns and the rows the times.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} data\_type is the string that represents the intensity measurements. Usually this contains if absolute
of differential data. This is used for the color intensity in the 2d plots and the y\sphinxhyphen{}axis for the 1d plots

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{units}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} this is used to identify the units on the energy axis and to label the slices, recognized is ‘nm’, ‘eV’ and ‘keV’
but if another unit like ‘cm\textasciicircum{}\sphinxhyphen{}1’ is used it will state energy in ‘cm\textasciicircum{}\sphinxhyphen{}1’. Pleas observe that if you use the index\_is\_energy
switch the program tries to convert this energy into wavelength.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sort\_indexes}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} For False (Default) I assume that the times and energies are already in a rising order.
with this switch, both are sorted again.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{divide\_times\_by}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} here a number can be given that scales the time by an arbitary factor. This is actually dividing
the times by this value. Alternatively there is the variable self.baseunit. The latter only affects
what is written on the axis, while this value is actually used to scale the times. False (Default)
ignores this

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{shift\_times\_by}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} This a value by which the time axis is shifted during import. This is a useful option of e.g.
the recording software does not compensate for t0 and the data is always shifted.
None (Default) ignores this setting

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{external\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Here a filename extension (string) can be given that contains the time vector.
The file is assumed to be at the same path as the data and to contain a single
type of separated data without header. It also assumes that this is the ending
for the file. The filename itself is taken from the filename.
e.g. if samp1.txt is the filename and external\_time=’.tid’ the program searches
samp1.tid for the times. The transpose setting is applied and sets where the times are
to be inserted (row or column indexes)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{external\_wave}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Here a filename extension (string) can be given that contains the wavelength vector.
The file is assumed to be at the same path as the data and to contain a single type
of separated data without header. This is the ending for the file. The filename itself
is taken from the filename. e.g. if samp1.txt is the filename and external\_wave=’.wav’
then the program searches samp1.wav for the wavelength. The transpose setting is applied
and sets where the wavelength are to be inserted (columns or row indexes)

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
List of opened TA objects

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{plot\PYGZus{}func} \PYG{k}{as} \PYG{n+nn}{pf}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{project\PYGZus{}list}\PYG{o}{=}\PYG{n}{pf}\PYG{o}{.}\PYG{n}{GUI\PYGZus{}open}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}start the GUI to open project Files}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{project\PYGZus{}list}\PYG{o}{=}\PYG{n}{pf}\PYG{o}{.}\PYG{n}{GUI\PYGZus{}open}\PYG{p}{(}\PYG{n}{fileending}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SIA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}start the GUI to open SIA Files}
\end{sphinxVerbatim}

Opening a list of files using the file names

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{project\PYGZus{}list}\PYG{o}{=}\PYG{n}{pf}\PYG{o}{.}\PYG{n}{GUI\PYGZus{}open}\PYG{p}{(}\PYG{n}{project\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{file1.SIA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{file2.SIA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Opening all files in the folder “all\_data” (relative to where the notebook is with the ending “hdf5”

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{project\PYGZus{}list}\PYG{o}{=}\PYG{n}{pf}\PYG{o}{.}\PYG{n}{GUI\PYGZus{}open}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{path}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{all\PYGZus{}data}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

Opening a list of files with external time vector (of the same name) so it looks for a data
file “file1.txt” and a file with the time information “file1.tid”

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{project\PYGZus{}list}\PYG{o}{=}\PYG{n}{pf}\PYG{o}{.}\PYG{n}{GUI\PYGZus{}open}\PYG{p}{(}\PYG{n}{project\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{file1.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{file2.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{external\PYGZus{}time} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{SVD() (in module plot\_func)@\spxentry{SVD()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.SVD}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{SVD}}}{\emph{\DUrole{n}{ds}}, \emph{\DUrole{n}{times}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{scattercut}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{bordercut}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{timelimits}\DUrole{o}{=}\DUrole{default_value}{{[}0.5, 150{]}}}, \emph{\DUrole{n}{wave\_nm\_bin}\DUrole{o}{=}\DUrole{default_value}{10}}, \emph{\DUrole{n}{time\_bin}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{wavelength\_bin}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plotting}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{baseunit}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}ps\textquotesingle{}}}, \emph{\DUrole{n}{title}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ignore\_time\_region}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cmap}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}differential Absorption in \$\textbackslash{}\textbackslash{}mathregular\{\textbackslash{}\textbackslash{}Delta OD\}\$\textquotesingle{}}}}{}
This function calculates the SVD and plots an overview.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ds}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}) \textendash{} This dataframe contains the data to be plotted. It is copied and sliced into the
regions defined. The dataframe expects the time to be in Index and the wavelength/energy
to be in the columns. The spectra is plotted with a second (energy) axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} are the number of components to be used in the SVD (Default) is None (which is seen as 6)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plotting}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} if True (Default) the functions plots the SVD, if False it returns the vectors

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} title to be used on top of each plot
The (Default) None triggers  self.filename to be used. Setting a specific title as string will
be used in all plots. To remove the title all together set an empty string with this command title=””

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{baseunit}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} baseunit is a neat way to change the unit on the time axis of the plots. (Default) ‘ps’, but they
can be frames or something similarly. This is changing only the label of the axis.
During the import there is the option to divide the numbers by a factor.
I have also used frames or fs as units. Important is that all time units will be labeled with
this unit.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{timelimits}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of 2 floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut times at the low and high time limit. (Default) {[}5e\sphinxhyphen{}1 , 150{]} uses the limits of measurement
Important: If either the background or the chirp is to be fit this must include the
time before zero! Useful: It is useful to work on different regions, starting with
the longest (then use the ta.Backgound function prior to fit) and expand from there

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scattercut}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{other iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{always pairs!}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} intented to “cut” one or multiple scatter regions. (if (Default) None nothing
happens) If it is set the spectral region between the limits is set to zero.
Usage single region: {[}lower region limit,upper region limit{]},
use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bordercut}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{with two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut spectra at the low and high wavelength limit. (Default) None
uses the limits of measurement

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wave\_nm\_bin}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} rebins the original data into even intervals. If set to None the original data will be used.
If set to a width (e.g. 2nm), the wavelength axis will be divided into steps of this size
and the mean of all measurements in the interval is taken. The re\sphinxhyphen{}binning stops as soon as
the measured stepsize is wider than given here, then the original bins are used.
This function is particularly useful for spectrometer with non\sphinxhyphen{}linear dispersion,
like a prism in the infrared. (Default = 10)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wavelength\_bin}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the width used in kinetics, see below (Default) 10nm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ignore\_time\_region}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{of lists}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut set a time range with a low and high limit from the fits. (Default) None nothing happens
The region will be removed during the fitting process (and will be missing in the fit\sphinxhyphen{}result
plots)
Usage single region: {[}lower region limit,upper region limit{]},
use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time\_bin}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is dividing the points on the time\sphinxhyphen{}axis in even bins and averages the found values in between.
This is a hard approach that also affects the fits. I do recommend to use this carefully,
it is most useful for modulated data. A better choice for transient absorption that only
affects the kinetics is ‘time\_width\_percent’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib color map}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is a powerfull variable that chooses the colour map applied for all plots. If set to
None (Default) then the self.cmap is used.
As standard I use the color map “jet” from matplotlib. There are a variety of colormaps
available that are very usefull. Beside “jet”, “viridis” is a good choice as it is well
visible under red\sphinxhyphen{}green blindness. Other useful maps are “prism” for high fluctuations
or diverging color maps like “seismic”.
See \sphinxurl{https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html} for a comprehensive
selection. In the code the colormaps are imported so if plot\_func is imported as pf then
self.cmap=pf.cm.viridis sets viridis as the map to use. Internally the colors are chosen
with the “colm” function. The 2d plots require a continuous color map so if something
else is give 2d plots are shown automatically with “jet”. For all of the 1d plots however
I first select a number of colors before each plot. If cmap is a continous map then these
are sampled evenly over the colourmap. Manual iterables of colours
cmap={[}(1,0,0),(0,1,0),(0,0,1),…{]} are also accepted, as are vectors or dataframes that
contain as rows the colors. There must be of course sufficient colors present for
the numbers of lines that will be plotted. So I recommend to provide at least 10 colours
(e.g.\textasciitilde{}your university colors). colours are always given as a, list or tuple with RGA or RGBA
(with the last A beeing the Alpha=transparency. All numbers are between 0 and 1.
If a list/vector/DataFrame is given for the colours they will be used in the order provided.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{Species\_Spectra() (in module plot\_func)@\spxentry{Species\_Spectra()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.Species_Spectra}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{Species\_Spectra}}}{\emph{\DUrole{n}{ta}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{conc}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{das}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
useful help function that returns a dictionary that has DataFrame as entries and the names of the
components as keys
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ta}} (\sphinxstyleliteralemphasis{\sphinxupquote{plot\_func.TA object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} This object should contain a successful fit. The function will cycle through the fitted species
and return the matrix that is formed from the dynamics and the species associated spectrum
If this given, then “conc” and “das” are ignored. We cycle through the columns of the concentration
and take the same column from the das Frame.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{conc}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Is read only if ta\_object is None. This should contain the concentration matrix with the species as
as columns

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{das}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} This should contain the spectra of the species with one column per spectrum. The position of the columns
must match the columns in the conc (at least this is what is assumed)

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

dicten=Species\_Spectra(ta)

\end{fulllineitems}

\index{Summarize\_scans() (in module plot\_func)@\spxentry{Summarize\_scans()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.Summarize_scans}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{Summarize\_scans}}}{\emph{\DUrole{n}{list\_of\_scans}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{path\_to\_scans}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}Scans\textquotesingle{}}}, \emph{\DUrole{n}{list\_to\_dump}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}range\textquotesingle{}}}, \emph{\DUrole{n}{window1}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{window2}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{save\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}combined.SIA\textquotesingle{}}}, \emph{\DUrole{n}{fileending}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}SIA\textquotesingle{}}}, \emph{\DUrole{n}{filename\_part}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}Scan\textquotesingle{}}}, \emph{\DUrole{n}{return\_removed\_list}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sep}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textbackslash{}t\textquotesingle{}}}, \emph{\DUrole{n}{decimal}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}.\textquotesingle{}}}, \emph{\DUrole{n}{index\_is\_energy}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{transpose}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sort\_indexes}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{divide\_times\_by}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{shift\_times\_by}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{external\_time}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{external\_wave}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{return\_ds\_only}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{data\_type}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{units}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Average single scans. Uses single scans of the data set and plots them as average after different conditions. Usually one defines one or two windows in which the intensity is integrated. This integrated number is then displayed for each scan in the list. There are different tools to select certain scans that are excluded from the summary. These are defined in the list\_to\_dump. This list can take either be a list with the number, or a string with the words ‘single’ or ‘range’ (see below)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{list\_of\_scans}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}gui\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} 
‘gui’ (choose scans via gui)

None (Default) load scan files from the specified folder (path\_to\_scans) with the specified file\sphinxhyphen{}ending
(file\_ending), if filename\_part is a string than only files with this string in the name are taken

list of names (strings) loads this list of files
list of integers (that will be directly attached to the filename\_part) to form the file name


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path\_to\_scans}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{path object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} specify relative or absolute path to the scan\sphinxhyphen{}files (Default:’Scans’)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_ending}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} specify the file extension of the single scan files. The Gui will only show this fileending
(Default: ‘.SIA’)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename\_part}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} specify a part of the string included in all scan\sphinxhyphen{}files (Default: ‘Scan’)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{window1}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list of 4 floats}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
window in time and wavelength over which each scan is averaged.

window must have the shape {[}start time, end time, start wavelength, end wavelength{]}
(Default: None)


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{window2}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of 4 floats}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
window in time and wavelength over which each scan is averaged.

window must have the shape {[}start time, end time, start wavelength, end wavelength{]}
(Default: None) IF not given then only one window will be displayed


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{list\_to\_dump}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}single\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{\textquotesingle{}range\textquotesingle{}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
takes a list of scans to be excluded from the average, this list can be indexes (order)
in which the scans come, or a list of names. if this is given as a list the option “range”
is offered, which allows to add additional selection to the cut.

\sphinxstylestrong{’single’} allows you (in a GUI) to click on single points in plotted window1 or two that
is to be removed, useful for spike removal and makes only sense in conjunction with at least
a defined window1, if none is defined window1 = {[}0.5,10,300,1200{]} will be set automatically.
A right click removes the last selection a middle click applies it. An empty middle click
(without selecting anything) finishes the gui

\sphinxstylestrong{’range’} allows you (in a GUI) to click and define regions.

first left click is the left side of the window, second left click the ride side of the window.
Third left click the left side of the second window,… A right click removes the last set point.
a middle click finishes and applies the selection

An \sphinxstylestrong{empty middle click} (without selecting anything) finishes the gui

useful for spike removal and definition of exclusion region (e.g. where the sample died)
This makes only sense in conjunction with at least a defined window1 ,
if none is defined window1 = {[}0.5,10,300,1200{]} will be set automatically


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} data\_type is the string that represents the intensity measurements. Usually this contains if absolute
of differential data. This is used for the color intensity in the 2d plots and the y\sphinxhyphen{}axis for the 1d plots

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{units}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} this is used to identify the units on the energy axis and to label the slices, recognized is ‘nm’, ‘eV’ and ‘keV’
but if another unit like ‘cm\textasciicircum{}\sphinxhyphen{}1’ is used it will state energy in ‘cm\textasciicircum{}\sphinxhyphen{}1’. Pleas observe that if you use the index\_is\_energy
switch the program tries to convert this energy into wavelength.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{save\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} specify name for saving the combined scans (Default) ‘combined.SIA’)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_removed\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) False, returns the list of removed scans instead of the averaged data set. (this list could then be given as “list\_to\_dump” to get the averaged datafile too. If a file name is given for saved file (which is Default) then the file is saved anyways.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sep}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} is the separator between different numbers, typical are tap (Backslash t) (Default) ,one or
multiple white spaces ‘backslash s+’ or comma ‘,’.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{decimal}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} sets the ascii symbol that is used for the decimal sign. In most countries this is ‘.’(Default)
but it can be ‘,’ in countries like Sweden or Germany

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{index\_is\_energy}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} switches if the wavelength is given in nm (Default) or in eV (if True), currently everything
is handled as wavelength in nm internally

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{transpose}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} if this switch is False (Default) the wavelength are the columns and the rows the times.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sort\_indexes}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} For False (Default) I assume that the times and energies are already in a rising order.
with this switch, both are sorted again.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{divide\_times\_by}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} here a number can be given that scales the time by an arbitary factor. This is actually dividing
the times by this value. Alternatively there is the variable self.baseunit. The latter only affects
what is written on the axis, while this value is actually used to scale the times. False (Default)
ignores this

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{shift\_times\_by}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} This a value by which the time axis is shifted during import. This is a useful option of e.g.
the recording software does not compensate for t0 and the data is always shifted.
None (Default) ignores this setting

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{external\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Here a filename extension (string) can be given that contains the time vector.
The file is assumed to be at the same path as the data and to contain a single
type of separated data without header. It also assumes that this is the ending
for the file. The filename itself is taken from the filename.
e.g. if samp1.txt is the filename and external\_time=’.tid’ the program searches
samp1.tid for the times. The transpose setting is applied and sets where the times are
to be inserted (row or column indexes)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{external\_wave}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Here a filename extension (string) can be given that contains the wavelength vector.
The file is assumed to be at the same path as the data and to contain a single type
of separated data without header. This is the ending for the file. The filename itself
is taken from the filename. e.g. if samp1.txt is the filename and external\_wave=’.wav’
then the program searches samp1.wav for the wavelength. The transpose setting is applied
and sets where the wavelength are to be inserted (columns or row indexes)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_ds\_only}} (\sphinxstyleliteralemphasis{\sphinxupquote{boolean}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} if False (Dafault) returns a TA object, otherwise just a DataFrame

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
\sphinxstyleemphasis{TA object if return\_ds\_only is False(Default) averaged dataset (ds) of the selected scans or}

\item {} 
\sphinxstyleemphasis{(if return\_removed\_list = True) the list of removed scans.}

\end{itemize}


\end{description}\end{quote}
\subsubsection*{Examples}

Use use a range to select the rejected scans, look on the scans by integrating the window 0.5ps to 1ps and 450nm to 470nm

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{plot\PYGZus{}func} \PYG{k}{as} \PYG{n+nn}{pf} \PYG{c+c1}{\PYGZsh{}import the module}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{window1}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{450}\PYG{p}{,}\PYG{l+m+mi}{470}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{}define the window}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{}use a \PYGZsq{}GUI\PYGZsq{} to select the files}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pf}\PYG{o}{.}\PYG{n}{Summarize\PYGZus{}scans}\PYG{p}{(}\PYG{n}{list\PYGZus{}of\PYGZus{}scans}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gui}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{window1}\PYG{o}{=}\PYG{n}{window1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{}use all scans in the subfolder scans that have the word \PYGZsq{}Scan\PYGZsq{} in them and use the ending \PYGZsq{}SIA\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pf}\PYG{o}{.}\PYG{n}{Summarize\PYGZus{}scans}\PYG{p}{(}\PYG{n}{path\PYGZus{}to\PYGZus{}scans} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Scans}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{filepart\PYGZus{}name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Scan}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{window1}\PYG{o}{=}\PYG{n}{window1}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{}This does the same as these are standard}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{pf}\PYG{o}{.}\PYG{n}{Summarize\PYGZus{}scans}\PYG{p}{(}\PYG{n}{window1}\PYG{o}{=}\PYG{n}{window1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{build\_c() (in module plot\_func)@\spxentry{build\_c()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.build_c}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{build\_c}}}{\emph{\DUrole{n}{times}}, \emph{\DUrole{n}{mod}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}paral\textquotesingle{}}}, \emph{\DUrole{n}{pardf}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{sub\_steps}\DUrole{o}{=}\DUrole{default_value}{10}}}{}
Build concentration matrix after model the parameters are:
resolution is the width of the rise time (at sigma 50\% intensity)
This function can also be used to create illustration dynamics.
The parallel decays are created explicit, while the consecutive decays are
created by sampling the populations at the times given in the first vector and
evaluate the progression at a number of substeps defined bu sub\_samples (10 by default)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}) \textendash{} array with the times at which the dataframe should be generated. In general the
experimental times

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mod}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
this selects the model that is used to generate the concentrations.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
’paral’ (Default) or ‘exponential’ both are equivalent

\item {} 
’consecutive’ or ‘full\_consecutive’

\end{enumerate}

In 2 the ‘consecutive’ and ‘full\_consecutive’ are different in that for consecutive
the optimization is done using ‘exponential’ (as it shoudl give the same times)
and then only in the last (final) iteration the ‘full consecutive’ differential
equation is used. This has significant speed advantages, but can lead to errors particularly
for the very fast times.


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sub\_step}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} defines how many times the iterative loop (used in consecutive only) is sampling the concentrations
between the times given in “times”

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pardf}} (\sphinxstyleliteralemphasis{\sphinxupquote{pd.DataFrame}}) \textendash{} 
This dataframe must contain the parameter that are used for creating the dynamics
the parameter must be named with the index.
For the internal functions this must contain these keys:
\begin{itemize}
\item {} 
’t0’ = zero time, mandatory

\item {} 
’resolution’ = instrument response function, mandatory

\item {} 
’background’,optional = if this keyword is present a flat constant background is created (=1 over the whole time)

\item {} 
’infinite’,optional = if this keyword is present a new non decaying component is formed with the last decay time.

\item {} 
’k0,k1,…’ = with increasing integers are taken as decay times. te number of these components is used to determine how many shall be generated.

\end{itemize}


\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

\end{fulllineitems}

\index{changefonts() (in module plot\_func)@\spxentry{changefonts()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.changefonts}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{changefonts}}}{\emph{\DUrole{n}{weight}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}bold\textquotesingle{}}}, \emph{\DUrole{n}{font}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}standard\textquotesingle{}}}, \emph{\DUrole{n}{SMALL\_SIZE}\DUrole{o}{=}\DUrole{default_value}{11}}, \emph{\DUrole{n}{MEDIUM\_SIZE}\DUrole{o}{=}\DUrole{default_value}{13}}, \emph{\DUrole{n}{LARGE\_SIZE}\DUrole{o}{=}\DUrole{default_value}{18}}}{}
Small function that sets the matplotlib font sizes and fonts, written as conveniens to not need to remember all the
codes and what is names what. Calling the function will change the matplotlib \sphinxstyleemphasis{rc} settings
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weight}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} ‘bold’ or  ‘normal’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{font}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
this is a meta switch that changes the family. known are:
‘standard’=’DejaVu Sans’

’arial’=’Arial’

’helvetica’= ‘Helvetica’

’garamond’=’Garamond’

’verdana’=’Verdana’

’bookman’=’Bookman’

’times’=’Times New Roman’


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{SMALL\_SIZE}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
(DEFAULT = 11)

all written text, legend title and face size


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{MEDIUM\_SIZE}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
(DEFAULT = 13)

tick size and tick numbers


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{LARGE\_SIZE}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
(DEFAULT = 18)

axis titles, figure titles, axis labels


\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{err\_func() (in module plot\_func)@\spxentry{err\_func()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.err_func}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{err\_func}}}{\emph{\DUrole{n}{paras}}, \emph{\DUrole{n}{ds}}, \emph{\DUrole{n}{mod}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}paral\textquotesingle{}}}, \emph{\DUrole{n}{final}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{log\_fit}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{dump\_paras}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{filename}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ext\_spectra}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
function that calculates and returns the error for the global fit. This function is intended for
fitting a single dataset.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ds}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}) \textendash{} This dataframe contains the data to be fitted. This has to be shaped as it is intended to (so all shping parameters
already applied. The dataframe expects the time to be in Index and the wavelength/energy
to be in the columns. The spectra is plotted with a second (energy) axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{paras}} (\sphinxstyleliteralemphasis{\sphinxupquote{lmfit parameter oject}}) \textendash{} The parameter object that defines what is calculated

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mod}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{function}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
The model selection is depending if it is an internal or external model.
The internal functions are triggered by calling their name
Two main are currently implemented
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
’paral’ (Default) or ‘exponential’

\item {} 
’consecutive’ or ‘full\_consecutive’

\end{enumerate}

In 2 the ‘consecutive’ and ‘full\_consecutive’ are different in that for consecutive
the optimization is done using ‘exponential’ (as it shoudl give the same times)
and then only in the last (final) iteration the ‘full consecutive’ differential
equation is used. This has significant speed advantages, but can lead to errors particularly
for the very fast times.

As external model a function is handed to this parameter, this function
must accept the times and an paramater Dataframe and return a DataFrame
with the concentrations (similar to build\_c)

for the internal functions:
This datafram must contain the parameter that are used for creadting the dynamics
the parameter must be named with the index.
‘t0’ = zero time, mandatory
‘resolution’ = instrument response function, mandatory
‘background’,optional = if this keyword is present a flat constant background is created (=1 over the whole time)
‘infinite’,optional = if this keyword is present a new non decaying component is formed with the last decay time.
‘k0,k1,…’ = with increasing integers are taken as decay times. te number of these components is used to determine how many shall be generated.


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{final}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} this switch decides if just the squared error is returned (for False) (Default) or if the full
matrixes are returned, including the r2 are returned.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{log\_fit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if False (Default) then the parameter are handed to the fitting function as they are, if true
then all times are first converted to log space.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dump\_paras}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) is False, If True creates two files in the working folder, one with the
currently used parameter created at the end of each optimisation step, and one with
the set of parameter that up to now gave the lowest error. Intented to store
the optimisation results if the fit needs to be interrupted
(if e.g. Ampgo simply needs to long to optimize.) useful option if things are slow

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Only used in conjunction with ‘dump\_paras’. The program uses this filename to dump the
parameter to disk

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ext\_spectra}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) is None, if given substract this spectra from the DataMatrix using the intensity
given in “C(t)” this function will only work for external models. The name of the spectral column
must be same as the name of the column used. If not the spectrum will be ignored. The spectrum will
be interpolated to the spectral points of the model ds before the substraction.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{err\_func\_multi() (in module plot\_func)@\spxentry{err\_func\_multi()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.err_func_multi}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{err\_func\_multi}}}{\emph{\DUrole{n}{paras}}, \emph{\DUrole{n}{mod}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}paral\textquotesingle{}}}, \emph{\DUrole{n}{final}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{log\_fit}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{multi\_project}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{unique\_parameter}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{weights}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{dump\_paras}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{filename}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ext\_spectra}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
function that calculates and returns the error for the global fit. This function is intended for
fitting of multiple datasets
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{paras}} (\sphinxstyleliteralemphasis{\sphinxupquote{lmfit parameter oject}}) \textendash{} The parameter object that defines what is calculated

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mod}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{function}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
The model selection is depending if it is an internal or external model.
The internal functions are triggered by calling their name
Two main are currently implemented
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
’paral’ (Default) or ‘exponential’

\item {} 
’consecutive’ or ‘full\_consecutive’

\end{enumerate}

In 2 the ‘consecutive’ and ‘full\_consecutive’ are different in that for consecutive
the optimization is done using ‘exponential’ (as it shoudl give the same times)
and then only in the last (final) iteration the ‘full consecutive’ differential
equation is used. This has significant speed advantages, but can lead to errors particularly
for the very fast times.

for the internal functions:
This datafram must contain the parameter that are used for creadting the dynamics
the parameter must be named with the index.
‘t0’ = zero time, mandatory
‘resolution’ = instrument response function, mandatory
‘background’,optional = if this keyword is present a flat constant background is created (=1 over the whole time)
‘infinite’,optional = if this keyword is present a new non decaying component is formed with the last decay time.
‘k0,k1,…’ = with increasing integers are taken as decay times. te number of these components is used to determine how many shall be generated.

As external model a function is handed to this parameter, this function
must accept the times and an paramater Dataframe and return a DataFrame
with the concentrations (similar to build\_c)


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{final}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} this switch decides if just the squared error is returned (for False) (Default) or if the full
matrixes are returned, including the r2 are returned.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{log\_fit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if False (Default) then the parameter are handed to the fitting function as they are, if true
then all times are first converted to log space.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dump\_paras}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) is False, If True creates two files in the working folder, one with the
currently used parameter created at the end of each optimisation step, and one with
the set of parameter that up to now gave the lowest error. Intented to store
the optimisation results if the fit needs to be interrupted
(if e.g. Ampgo simply needs to long to optimize.) useful option if things are slow

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Only used in conjunction with ‘dump\_paras’. The program uses this filename to dump the
parameter to disk

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{multi\_project}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of TA projects}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} This switch is triggering the simultaneous optimisation of multiple datasets.
multi\_project is as (Default) None. it expects an iterable (typically list) with other
TA projects (like ta) that are then optimised with the same parameter.
This means that all projects get the same parameter object for each iteration
of the fit and return their individual error, which is summed linearly.
The “weights” option allows to give each multi\_project a specific weight (number)
that is multiplied to the error. If the weight object has the same number of items
as the multi\_project it is assumed that the triggering object (the embedded project)
has the weight of 1, otherwise the first weight is for the embedded project.
The option ‘unique\_parameter’ takes (a list) of parameter that are not
to be shared between the projects (and that are not optimized either)
The intended use of this is to give e.g. the pump power for multiple experiments to
study non linear behaviour. Returned will be only the parameter set for the optimium
combination of all parameter. Internally, we iterate through the projects and calculate
for each project the error for each iteration. Important to note is that currently this
means that each DAS/SAS is calculated independently! For performing the same calculation
with a single DAS, the Matrixes need to be concatenated before the run and an external
function used to create a combined model. As this is very difficult to implement reliably
For general use (think e.g. different pump wavelength) this has to be done manually.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{unique\_parameter}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of strings}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} only used in conjunction with ‘multi\_project’, it takes (a list) of parameter that
are not to be shared between the projects (and that are not optimized either)
The intended use of this is to give e.g. the pump power for multiple experiments
to study non linear behaviour. (Default) None

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weights}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} only used in conjunction with ‘multi\_project’. The “weights” option allows to
give each multi\_project a specific weight (number) that is multiplied to the error.
If the weight object has the same number of items as the ‘multi\_project’ it is assumed
that ta (the embedded project) has the weight of 1, otherwise the first weight is for the
embedded object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ext\_spectra}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) is None, if given substract this spectra from the DataMatrix using the intensity
given in “C(t)” this function will only work for external models. The name of the spectral column
must be same as the name of the column used. If not the spectrum will be ignored. The spectrum will
be interpolated to the spectral points of the model ds before the substraction.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{fill\_int() (in module plot\_func)@\spxentry{fill\_int()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.fill_int}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{fill\_int}}}{\emph{\DUrole{n}{ds}}, \emph{\DUrole{n}{c}}, \emph{\DUrole{n}{final}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{baseunit}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}ps\textquotesingle{}}}}{}
solving the intensity an equation\_way, takes the target dataframe and the concentration frame
prepares the matrixes(c) the tries to solve this equation system using
eps=np.linalg.lstsq(AA,Af,rcond=\sphinxhyphen{}1){[}0{]}
if failes it returns a dictionary with 1000 as error (only entry) if successful
it returns a dictionary that contains the
fit\_error = (AE**2).sum() with AE beeing the difference of measured and calcuated matrix
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ds}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}) \textendash{} DataFrame to be fitted

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{c}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}) \textendash{} DataFrame oontaining the concentration matrix (the concentrations as with the times as index.
Each different species has a column with the species name as column name

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{final}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if True (Default) the complete solutions will be attached otherwise only the error is attached

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{baseunit}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} this string is used as unit for the time axis

\end{itemize}

\item[{Returns}] \leavevmode

\sphinxstylestrong{re} \textendash{} the dictionary “re” attached to the object containing all the matrixes and parameter.

if “final” is True:
\begin{itemize}
\item {} 
”A” Shaped measured Matrix

\item {} 
”AC” Shaped calculated Matrix

\item {} 
”AE” Difference between A and AC = linear error

\item {} 
”DAC” DAS or SAS, labeled after the names given in the function (the columns of c) Care must be taken that this mesured intensity is C * DAS, the product. For exponential model the concentrations are normalized

\item {} 
”c” The Concentrations (meaning the evolution of the concentrations over time. Care must be taken that this mesured intensity is C * DAS, the product. For exponential model the concentrations are normalized

\item {} 
”error” is the S2, meaning AE**2.sum().sum()

\end{itemize}

else:
\begin{itemize}
\item {} 
”error” is the S2, meaning AE**2.sum()

\end{itemize}


\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{norm() (in module plot\_func)@\spxentry{norm()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.norm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{norm}}}{\emph{\DUrole{n}{df}}}{}
Min max norming of a dataframe

\end{fulllineitems}

\index{plot1d() (in module plot\_func)@\spxentry{plot1d()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.plot1d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{plot1d}}}{\emph{ds=None}, \emph{wavelength=None}, \emph{width=None}, \emph{ax=None}, \emph{subplot=False}, \emph{title=None}, \emph{intensity\_range=None}, \emph{baseunit=\textquotesingle{}ps\textquotesingle{}}, \emph{timelimits=None}, \emph{scattercut=None}, \emph{bordercut=None}, \emph{cmap=\textless{}matplotlib.colors.ListedColormap object\textgreater{}}, \emph{plot\_type=\textquotesingle{}symlog\textquotesingle{}}, \emph{lintresh=0.1}, \emph{text\_in\_legend=None}, \emph{lines\_are=\textquotesingle{}smoothed\textquotesingle{}}, \emph{color\_offset=0}, \emph{ignore\_time\_region=None}, \emph{linewidth=1}, \emph{data\_type=\textquotesingle{}differential Absorption in \$\textbackslash{}\textbackslash{}mathregular\{\textbackslash{}\textbackslash{}Delta OD\}\$\textquotesingle{}}, \emph{units=\textquotesingle{}nm\textquotesingle{}}}{}
Plots the single line kinetic for specific wavelength given with the parameter wavelength.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ds}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}) \textendash{} This dataframe contains the data to be plotted. It is copied and sliced into the
regions defined. The dataframe expects the time to be in Index and the wavelength/energy
to be in the columns. The spectra is plotted with a second (energy) axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wavelength}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} wavelength is in the object called “rel\_wave” and works with “width”
(in the object called “wavelength\_bin”) together for the creation
of kinetic plots. When plotting kinetic spectra one line will be plotted for each entrance
in the list/vector rel\_wave. During object generation the vector np.arange(300,1000,100)
is set as standard. Another typical using style would be to define a list of interesting
wavelength at which a kinetic development is to be plotted. At each selected wavelength
the data between wavelength+ta.wavelength\_bin and wavelength\sphinxhyphen{}ta.wavelength\_bin is averaged
for each timepoint returned

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} this is the datatype and effectively the unit put on the intensity axis
(Default)’differential Absorption in \$mathregular\{Delta OD\}\$

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{width}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the width used in kinetics, see below (Default) 10nm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib axis object optional}}) \textendash{} If None (Default) a new plot is is created and a new axis, otherwise ax needs to be Matplotlib Axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{subplot}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If False (Default) axis labels and such are set. If True, we plot into the same axis and
do not set labels

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{text\_in\_legend}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} extra text to be put into the legend (above the lines)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lines\_are}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} Depending on this parameter the plots contain:
‘smoothed’ = data lines of golay smoothed data (Default)
‘data’ = dots are data,
‘fitted’ = not data, just lines shown

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} title to be used on top of each plot
The (Default) None triggers  self.filename to be used. Setting a specific title as string will
be used in all plots. To remove the title all together set an empty string

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{linewidth}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} linewidht to be used for plotting

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{intensity\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{of two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} intensity\_range is a general switch that governs what intensity range the plots show.
For the 1d plots this is the y\sphinxhyphen{}axis for the 2d\sphinxhyphen{}plots this is the colour scale.
This parameter recognizes three settings. If set to “None” (Default) this uses the minimum and
maximum of the data. A single value like in the example below and the intended use is the symmetric
scale while a list with two entries an assymmetric scale e.g.
intensity\_range=3e\sphinxhyphen{}3 is converted into intensity\_range={[}\sphinxhyphen{}3e\sphinxhyphen{}3,3e\sphinxhyphen{}3{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{baseunit}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} baseunit is a neat way to change the unit on the time axis of the plots. (Default) ‘ps’, but they
can be frames or something similarly. This is changing only the label of the axis.
During the import there is the option to divide the numbers by a factor.
I have also used frames or fs as units. Important is that all time units will be labeled with
this unit.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{timelimits}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of 2 floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut times at the low and high time limit. (Default) None uses the limits of measurement
Important: If either the background or the chirp is to be fit this must include the
time before zero! Useful: It is useful to work on different regions, starting with
the longest (then use the ta.Backgound function prior to fit) and expand from there

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scattercut}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{other iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{always pairs!}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} intented to “cut” one or multiple scatter regions. (if (Default) None nothing
happens) If it is set the spectral region between the limits is set to zero.
Usage single region: {[}lower region limit,upper region limit{]},
use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bordercut}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{with two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut spectra at the low and high wavelength limit. (Default) None
uses the limits of measurement

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ignore\_time\_region}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{of lists}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut set a time range with a low and high limit from the fits. (Default) None nothing happens
The region will be removed during the fitting process (and will be missing in the fit\sphinxhyphen{}result
plots)
Usage single region: {[}lower region limit,upper region limit{]},
use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib color map}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is a powerfull variable that chooses the colour map applied for all plots. If set to
None (Default) then the self.cmap is used.
As standard I use the color map “jet” from matplotlib. There are a variety of colormaps
available that are very usefull. Beside “jet”, “viridis” is a good choice as it is well
visible under red\sphinxhyphen{}green blindness. Other useful maps are “prism” for high fluctuations
or diverging color maps like “seismic”.
See \sphinxurl{https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html} for a comprehensive
selection. In the code the colormaps are imported so if plot\_func is imported as pf then
self.cmap=pf.cm.viridis sets viridis as the map to use. Internally the colors are chosen
with the “colm” function. The 2d plots require a continuous color map so if something
else is give 2d plots are shown automatically with “jet”. For all of the 1d plots however
I first select a number of colors before each plot. If cmap is a continous map then these
are sampled evenly over the colourmap. Manual iterables of colours
cmap={[}(1,0,0),(0,1,0),(0,0,1),…{]} are also accepted, as are vectors or dataframes that
contain as rows the colors. There must be of course sufficient colors present for
the numbers of lines that will be plotted. So I recommend to provide at least 10 colours
(e.g.your university colors). colours are always given as a, list or tuple with RGA or RGBA
(with the last A beeing the Alpha=transparency. All numbers are between 0 and 1.
If a list/vector/DataFrame is given for the colours they will be used in the order provided.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{color\_offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} At the (Default) 0 the colours are chose from the beginning, for a larger value Color\_offset
colors are skipped. Usually only used if multiple plots are created, and the data/or fit is
only shown for some of them.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plot\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} is a general setting that can influences what time axis will be used for the plots.
“symlog” (linear around zero and logarithmic otherwise) “lin” and “log” are valid options.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lintresh}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The pseudo logratihmic range “symlog” is used for most time axis. Symlog plots a range around
time zero linear and beyond this linear treshold ‘lintresh’ on a logarithmic scale. (Default) 0.3

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot2d() (in module plot\_func)@\spxentry{plot2d()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.plot2d}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{plot2d}}}{\emph{\DUrole{n}{ds}}, \emph{\DUrole{n}{ax}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{title}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{intensity\_range}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{baseunit}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}ps\textquotesingle{}}}, \emph{\DUrole{n}{timelimits}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{scattercut}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{bordercut}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{wave\_nm\_bin}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ignore\_time\_region}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{time\_bin}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{log\_scale}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{plot\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}symlog\textquotesingle{}}}, \emph{\DUrole{n}{lintresh}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{wavelength\_bin}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{levels}\DUrole{o}{=}\DUrole{default_value}{256}}, \emph{\DUrole{n}{use\_colorbar}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{cmap}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}differential Absorption in \$\textbackslash{}\textbackslash{}mathregular\{\textbackslash{}\textbackslash{}Delta OD\}\$\textquotesingle{}}}}{}
function for plotting matrix of TA data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ds}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}) \textendash{} This dataframe contains the data to be plotted. It is copied and sliced into the
regions defined. The dataframe expects the time to be in Index and the wavelength/energy
to be in the columns. The spectra is plotted with a second (energy) axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib axis object optional}}) \textendash{} If None (Default) a new plot is is created and a new axis, otherwise ax needs to be Matplotlib Axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} this is the datatype and effectively the unit put on the intensity axis
(Default)’differential Absorption in \$mathregular\{Delta OD\}\$

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} title to be used on top of each plot
The (Default) None triggers  self.filename to be used. Setting a specific title as string will
be used in all plots. To remove the title all together set an empty string with this command title=””

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{intensity\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{of two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} intensity\_range is a general switch that governs what intensity range the plots show.
For the 1d plots this is the y\sphinxhyphen{}axis for the 2d\sphinxhyphen{}plots this is the colour scale.
This parameter recognizes three settings. If set to “None” (Default) this uses the minimum and
maximum of the data. A single value like in the example below and the intended use is the symmetric
scale while a list with two entries an assymmetric scale e.g.
intensity\_range=3e\sphinxhyphen{}3 is converted into intensity\_range={[}\sphinxhyphen{}3e\sphinxhyphen{}3,3e\sphinxhyphen{}3{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{baseunit}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} baseunit is a neat way to change the unit on the time axis of the plots. (Default) ‘ps’, but they
can be frames or something similarly. This is changing only the label of the axis.
During the import there is the option to divide the numbers by a factor.
I have also used frames or fs as units. Important is that all time units will be labeled with
this unit.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{timelimits}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of 2 floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut times at the low and high time limit. (Default) None uses the limits of measurement
Important: If either the background or the chirp is to be fit this must include the
time before zero! Useful: It is useful to work on different regions, starting with
the longest (then use the ta.Backgound function prior to fit) and expand from there

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scattercut}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{other iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{always pairs!}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} intented to “cut” one or multiple scatter regions. (if (Default) None nothing
happens) If it is set the spectral region between the limits is set to zero.
Usage single region: {[}lower region limit,upper region limit{]},
use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bordercut}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{with two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut spectra at the low and high wavelength limit. (Default) None
uses the limits of measurement

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wave\_nm\_bin}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} rebins the original data into even intervals. If set to None the original data will be used.
If set to a width (e.g. 2nm), the wavelength axis will be divided into steps of this size
and the mean of all measurements in the interval is taken. The re\sphinxhyphen{}binning stops as soon as
the measured stepsize is wider than given here, then the original bins are used.
This function is particularly useful for spectrometer with non\sphinxhyphen{}linear dispersion,
like a prism in the infrared.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ignore\_time\_region}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{of lists}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut set a time range with a low and high limit from the fits. (Default) None nothing happens
The region will be removed during the fitting process (and will be missing in the fit\sphinxhyphen{}result
plots)
Usage single region: {[}lower region limit,upper region limit{]},
use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time\_bin}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is dividing the points on the time\sphinxhyphen{}axis in even bins and averages the found values in between.
This is a hard approach that also affects the fits. I do recommend to use this carefully,
it is most useful for modulated data. A better choice for transient absorption that only
affects the kinetics is ‘time\_width\_percent’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{log\_scale}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If True (Default), The 2D plots (Matrix) is plotted with a pseudo logarithmic intensity scale.
This usually does not give good results unless the intensity scale is symmetric

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plot\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} is a general setting that can influences what time axis will be used for the plots.
“symlog” (linear around zero and logarithmic otherwise) “lin” and “log” are valid options.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lintresh}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The pseudo logratihmic range “symlog” is used for most time axis. Symlog plots a range around
time zero linear and beyond this linear treshold ‘lintresh’ on a logarithmic scale. (Default) 0.3

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wavelength\_bin}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the width used in kinetics, see below (Default) 10nm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{levels}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} how many different colours to use in the description. less makes for more contrast but less
intensity details (Default) 256

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{use\_colorbar}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if True (Default) a colour bar is added to the 2d plot for intensity explanation, switch
mostely used for creating multiple plots

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib color map}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is a powerfull variable that chooses the colour map applied for all plots. If set to
None (Default) then the self.cmap is used.
As standard I use the color map “jet” from matplotlib. There are a variety of colormaps
available that are very usefull. Beside “jet”, “viridis” is a good choice as it is well
visible under red\sphinxhyphen{}green blindness. Other useful maps are “prism” for high fluctuations
or diverging color maps like “seismic”.
See \sphinxurl{https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html} for a comprehensive
selection. In the code the colormaps are imported so if plot\_func is imported as pf then
self.cmap=pf.cm.viridis sets viridis as the map to use. Internally the colors are chosen
with the “colm” function. The 2d plots require a continuous color map so if something
else is give 2d plots are shown automatically with “jet”. For all of the 1d plots however
I first select a number of colors before each plot. If cmap is a continous map then these
are sampled evenly over the colourmap. Manual iterables of colours
cmap={[}(1,0,0),(0,1,0),(0,0,1),…{]} are also accepted, as are vectors or dataframes that
contain as rows the colors. There must be of course sufficient colors present for
the numbers of lines that will be plotted. So I recommend to provide at least 10 colours
(e.g.\textasciitilde{}your university colors). colours are always given as a, list or tuple with RGA or RGBA
(with the last A beeing the Alpha=transparency. All numbers are between 0 and 1.
If a list/vector/DataFrame is given for the colours they will be used in the order provided.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot2d\_fit() (in module plot\_func)@\spxentry{plot2d\_fit()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.plot2d_fit}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{plot2d\_fit}}}{\emph{\DUrole{n}{re}}, \emph{\DUrole{n}{error\_matrix\_amplification}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{use\_images}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{patches}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{title}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{intensity\_range}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{baseunit}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}ps\textquotesingle{}}}, \emph{\DUrole{n}{timelimits}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{scattercut}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{bordercut}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{wave\_nm\_bin}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ignore\_time\_region}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{time\_bin}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{log\_scale}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{scale\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}symlog\textquotesingle{}}}, \emph{\DUrole{n}{lintresh}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{wavelength\_bin}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{levels}\DUrole{o}{=}\DUrole{default_value}{256}}, \emph{\DUrole{n}{plot\_with\_colorbar}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{cmap}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}differential Absorption in \$\textbackslash{}\textbackslash{}mathregular\{\textbackslash{}\textbackslash{}Delta OD\}\$\textquotesingle{}}}}{}
Plots the fit output as a single plot with meas,fitted and difference.
The differnece used err\_matrix\_amplification as a factor. patches moves the labels from the
title into white patches in the top of the figure
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{re}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionary that contains the fit results and  specific the dataframes A, AC and AE

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{error\_matrix\_amplification}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the error matrix AE is multiplied by this factor for the plot.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{use\_images}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool:}}) \textendash{} (Default)True converts the matrix into images, to reduce the filesize.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} this is the datatype and effectively the unit put on the intensity axis
(Default)’differential Absorption in \$mathregular\{Delta OD\}\$

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{patches}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If False (Default) the names “measured” “fitted” “difference” will be placed above the images.
If True, then they will be included into the image (denser)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} title to be used on top of each plot
The (Default) None triggers  self.filename to be used. Setting a specific title as string will
be used in all plots. To remove the title all together set an empty string with this command title=””

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{intensity\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{of two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} intensity\_range is a general switch that governs what intensity range the plots show.
For the 1d plots this is the y\sphinxhyphen{}axis for the 2d\sphinxhyphen{}plots this is the colour scale.
This parameter recognizes three settings. If set to “None” (Default) this uses the minimum and
maximum of the data. A single value like in the example below and the intended use is the symmetric
scale while a list with two entries an assymmetric scale e.g.
intensity\_range=3e\sphinxhyphen{}3 is converted into intensity\_range={[}\sphinxhyphen{}3e\sphinxhyphen{}3,3e\sphinxhyphen{}3{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{baseunit}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} baseunit is a neat way to change the unit on the time axis of the plots. (Default) ‘ps’, but they
can be frames or something similarly. This is changing only the label of the axis.
During the import there is the option to divide the numbers by a factor.
I have also used frames or fs as units. Important is that all time units will be labeled with
this unit.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{timelimits}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of 2 floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut times at the low and high time limit. (Default) None uses the limits of measurement
Important: If either the background or the chirp is to be fit this must include the
time before zero! Useful: It is useful to work on different regions, starting with
the longest (then use the ta.Backgound function prior to fit) and expand from there

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scattercut}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{other iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{always pairs!}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} intented to “cut” one or multiple scatter regions. (if (Default) None nothing
happens) If it is set the spectral region between the limits is set to zero.
Usage single region: {[}lower region limit,upper region limit{]},
use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bordercut}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{with two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut spectra at the low and high wavelength limit. (Default) None
uses the limits of measurement

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wave\_nm\_bin}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} rebins the original data into even intervals. If set to None the original data will be used.
If set to a width (e.g. 2nm), the wavelength axis will be divided into steps of this size
and the mean of all measurements in the interval is taken. The re\sphinxhyphen{}binning stops as soon as
the measured stepsize is wider than given here, then the original bins are used.
This function is particularly useful for spectrometer with non\sphinxhyphen{}linear dispersion,
like a prism in the infrared.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ignore\_time\_region}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{of lists}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut set a time range with a low and high limit from the fits. (Default) None nothing happens
The region will be removed during the fitting process (and will be missing in the fit\sphinxhyphen{}result
plots)
Usage single region: {[}lower region limit,upper region limit{]},
use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time\_bin}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is dividing the points on the time\sphinxhyphen{}axis in even bins and averages the found values in between.
This is a hard approach that also affects the fits. I do recommend to use this carefully,
it is most useful for modulated data. A better choice for transient absorption that only
affects the kinetics is ‘time\_width\_percent’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{log\_scale}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If True (Default), The 2D plots (Matrix) is plotted with a pseudo logarithmic intensity scale.
This usually does not give good results unless the intensity scale is symmetric

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Scale\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} is a general setting that can influences what time axis will be used for the plots.
“symlog” (linear around zero and logarithmic otherwise) “lin” and “log” are valid options.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lintresh}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The pseudo logratihmic range “symlog” is used for most time axis. Symlog plots a range around
time zero linear and beyond this linear treshold ‘lintresh’ on a logarithmic scale. (Default) 0.3

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wavelength\_bin}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the width used in kinetics, see below (Default) 10nm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{levels}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} how many different colours to use in the description. less makes for more contrast but less
intensity details (Default) 256

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plot\_with\_colorbar}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if True (Default) a colour bar is added to the 2d plot for intensity explanation, switch
mostely used for creating multiple plots

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib color map}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is a powerfull variable that chooses the colour map applied for all plots. If set to
None (Default) then the self.cmap is used.
As standard I use the color map “jet” from matplotlib. There are a variety of colormaps
available that are very usefull. Beside “jet”, “viridis” is a good choice as it is well
visible under red\sphinxhyphen{}green blindness. Other useful maps are “prism” for high fluctuations
or diverging color maps like “seismic”.
See \sphinxurl{https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html} for a comprehensive
selection. In the code the colormaps are imported so if plot\_func is imported as pf then
self.cmap=pf.cm.viridis sets viridis as the map to use. Internally the colors are chosen
with the “colm” function. The 2d plots require a continuous color map so if something
else is give 2d plots are shown automatically with “jet”. For all of the 1d plots however
I first select a number of colors before each plot. If cmap is a continous map then these
are sampled evenly over the colourmap. Manual iterables of colours
cmap={[}(1,0,0),(0,1,0),(0,0,1),…{]} are also accepted, as are vectors or dataframes that
contain as rows the colors. There must be of course sufficient colors present for
the numbers of lines that will be plotted. So I recommend to provide at least 10 colours
(e.g.\textasciitilde{}your university colors). colours are always given as a, list or tuple with RGA or RGBA
(with the last A beeing the Alpha=transparency. All numbers are between 0 and 1.
If a list/vector/DataFrame is given for the colours they will be used in the order provided.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_fit\_output() (in module plot\_func)@\spxentry{plot\_fit\_output()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.plot_fit_output}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{plot\_fit\_output}}}{\emph{re, ds, cmap=\textless{}matplotlib.colors.ListedColormap object\textgreater{}, plotting=range(0, 6), title=None, path=None, filename=None, f=\textquotesingle{}standard\textquotesingle{}, intensity\_range=0.01, baseunit=\textquotesingle{}ps\textquotesingle{}, timelimits=None, scattercut=None, bordercut=None, error\_matrix\_amplification=20, wave\_nm\_bin=5, rel\_wave=None, width=10, rel\_time={[}1, 5, 10{]}, time\_width\_percent=10, ignore\_time\_region=None, save\_figures\_to\_folder=True, log\_fit=False, mod=None, subplot=False, color\_offset=0, log\_scale=True, savetype=\textquotesingle{}png\textquotesingle{}, evaluation\_style=False, lintresh=1, scale\_type=\textquotesingle{}symlog\textquotesingle{}, patches=False, print\_click\_position=False, data\_type=\textquotesingle{}differential Absorption in \$\textbackslash{}\textbackslash{}mathregular\{\textbackslash{}\textbackslash{}Delta OD\}\$\textquotesingle{}, plot\_second\_as\_energy=True, units=\textquotesingle{}nm\textquotesingle{}}}{}
Purly manual function that plots all the fit output figures. Quite cumbersome,
but offers a lot of manual options. The figures can be called separately
or with a list of plots. e.g. range(6) call plots 0\sphinxhyphen{}5 Manual plotting of certain type:
This is a wrapper function that triggers the plotting of all the fitted plots.
The parameter in this plot call are to control the general look and features of the plot.
Which plots are printed is defined by the command (plotting)
The plots are generated from the fitted Matrixes and as such only will work after a fit was actually
completed (and the “re” dictionary attached to the object.)
In all plots the RAW data is plotted as dots and the fit with lines

\sphinxstyleemphasis{Contents of the plots}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{-1}
\item {} 
DAC contains the assigned spectra for each component of the fit. For
a modelling with independent exponential decays this corresponds to
the “Decay Associated Spectra” (DAS). For all other models this
contains the “Species Associated Spectra” (SAS). According to the
model the separate spectra are labeled by time (process) or name, if
a name is associated in the fitting model. The spectra are shown in
the extracted strength in the right pane and normalized in the left.
Extracted strength means that the measured spectral strength is the
intensity (concentration matrix) times this spectral strength. As the
concentration maxima for all DAS are 1 this corresponds to the
spectral strength for the DAS. (please see the documentation for the
fitting algorithm for further details)

\item {} 
summed intensity. All wavelength of the spectral axis are summed for
data and fit. The data is plotted in a number of ways vs linear and
logarithmic axis. This plot is not ment for publication but very
useful to evaluate the quality of a fit.

\item {} 
plot kinetics for selected wavelength (see corresponding RAW plot)

\item {} 
plot spectra at selected times (see corresponding RAW plot)

\item {} 
plots matrix (measured, modelled and error Matrix). The parameter are
the same as used for the corresponding RAW plot with the addition of
“error\_matrix\_amplification” which is a scaling factor multiplied
onto the error matrix. I recommend to play with different “cmap”,
“log\_scale” and “intensity\_scale” to create a pleasing plot

\item {} 
concentrations. In the progress of the modelling/fitting a matrix is
generated that contains the relative concentrations of the species
modelled. This plot is showing the temporal development of these
species. Further details on how this matrix is generated can be found
in the documentation of the fitting function. The modeled spectra are
the convolution of these vectors (giving the time\sphinxhyphen{}development) and
the DAS/SAS (giving the spectral development).

\end{enumerate}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ds}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}) \textendash{} This dataframe contains the data to be plotted. It is copied and sliced into the
regions defined. The dataframe expects the time to be in Index and the wavelength/energy
to be in the columns. The spectra is plotted with a second (energy) axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{re}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} Dictionary that contains the fit results and  specific the dataframes A, AC and AE

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} this is the datatype and effectively the unit put on the intensity axis
(Default)’differential Absorption in \$mathregular\{Delta OD\}\$

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{error\_matrix\_amplification}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the error matrix AE is multiplied by this factor for the plot.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plotting}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of integers}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} This parameter determines which figures are plotted
the figures can be called separately with plotting = 1
or with a list of plots (Default) e.g.\textasciitilde{}plotting=range(6) calls plots 0,1,2,3,4,5
The plots have the following numbers:           0 \sphinxhyphen{} DAS or SAS          1 \sphinxhyphen{} summed intensity            2 \sphinxhyphen{} Kinetics            3 \sphinxhyphen{} Spectra             4 \sphinxhyphen{} Matrixes            5 \sphinxhyphen{} Concentrations (the c\sphinxhyphen{}object)               The plotting takes all parameter from the “ta” object unless otherwise specified

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{path object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} This defines where the files are saved if the safe\_figures\_to\_folder parameter is True,
quite useful if a lot of data sets are to be printed fast.
If a path is given, this is used. If a string like the (Default) “result\_figures” is given,
then a subfolder of this name will be used (an generated if necessary)
relative to self.path. Use and empty string to use the self.path
If set to None, the location of the plot\_func will be used and
a subfolder with title “result\_figures” be generated here

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{savetype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} matplotlib allows the saving of figures in various formats. (Default) “png”,
typical and recommendable options are “svg” and “pdf”.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{evaluation\_style}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} True (Default = False) adds a lot of extra information in the plot

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} “title=None” is in general the filename that was loaded. Setting a
specific title will be used in all plots. To remove the title all
together set an empty string with title=””

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scale\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} refers to the time\sphinxhyphen{}axis and takes, ’symlog’ (Default)(linear around zero and logarithmic otherwise)
and ‘lin’ for linear and  ‘log’ for logarithmic, switching all the time axis to this type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{patches}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If False (Default) the names “measured” “fitted” “difference” will be placed above the images.
If True, then they will be included into the image (denser)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} offers to replace the base\sphinxhyphen{}name used for all plots (to e.g.\textasciitilde{}specify what sample was used).
if (Default) None is used, the self.filename is used as a base name. The filename plays only a
role during saving, as does the path and savetype

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{save\_figures\_to\_folder}] \leavevmode{[}bool, optional{]}
(Default) is True, if True the Figures are automatically saved

\item[{log\_scale}] \leavevmode{[}bool, optional{]}
If True (Default), The 2D plots (Matrix) is plotted with a pseudo logarithmic intensity scale.
This usually does not give good results unless the intensity scale is symmetric

\item[{subplot}] \leavevmode{[}bool, optional{]}
If False (Default) axis labels and such are set. If True, we plot into the same axis and
do not set labels

\item[{color\_offset}] \leavevmode{[}int, optional{]}
At the (Default) 0 the colours are chose from the beginning, for a larger value Color\_offset
colors are skipped. Usually only used if multiple plots are created, and the data/or fit is
only shown for some of them.

\item[{lintresh}] \leavevmode{[}float{]}
The pseudo logratihmic range “symlog” is used for most time axis. Symlog plots a range around
time zero linear and beyond this linear treshold ‘lintresh’ on a logarithmic scale. (Default) 1

\item[{rel\_time}] \leavevmode{[}float or list/vector (of floats), optional{]}
For each entry in rel\_time a spectrum is plotted. If time\_width\_percent=0 (Default) the
nearest measured timepoint is chosen. For other values see ‘time\_width\_percent’

\item[{time\_width\_percent}] \leavevmode{[}float{]}
“rel\_time” and “time\_width\_percent” work together for creating spectral plots at
specific timepoints. For each entry in rel\_time a spectrum is plotted.
If however e.g. time\_width\_percent=10 the region between the timepoint closest
to the  1.1 x timepoint and 0.9 x timepoint is averaged and shown
(and the legend adjusted accordingly). This is particularly useful for the densly
sampled region close to t=0. Typically for a logarithmic recorded kinetics, the
timepoints at later times will be further appart than 10 percent of the value,
but this allows to elegantly combine values around time=0 for better statistics.
This averaging is only applied for the plotting function and not for the fits.

\item[{ignore\_time\_region}] \leavevmode{[}None or list (of two floats or of lists), optional{]}
cut set a time range with a low and high limit from the fits. (Default) None nothing happens
The region will be removed during the fitting process (and will be missing in the fit\sphinxhyphen{}result
plots)
Usage single region: {[}lower region limit,upper region limit{]},
use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item[{width}] \leavevmode{[}float, optional{]}
the width used in kinetics, see below (Default) 10nm

\item[{rel\_wave}] \leavevmode{[}float or list (of floats), optional{]}
‘rel\_wave’ and ‘width’ (in the object called ‘wavelength\_bin’ work together for the creation
of kinetic plots. When plotting kinetic spectra one line will be plotted for each entrance
in the list/vector rel\_wave. During object generation the vector np.arange(300,1000,100)
is set as standard. Another typical using style would be to define a list of interesting
wavelength at which a kinetic development is to be plotted. At each selected wavelength
the data between wavelength+ta.wavelength\_bin and wavelength\sphinxhyphen{}ta.wavelength\_bin is averaged
for each timepoint returned

\item[{timelimits}] \leavevmode{[}None or list (of 2 floats), optional{]}
cut times at the low and high time limit. (Default) None uses the limits of measurement
Important: If either the background or the chirp is to be fit this must include the
time before zero! Useful: It is useful to work on different regions, starting with
the longest (then use the ta.Backgound function prior to fit) and expand from there

\item[{scattercut}] \leavevmode{[}None or iterable (of floats or other iterable, always pairs!), optional{]}
intented to “cut” one or multiple scatter regions. (if (Default) None nothing
happens) If it is set the spectral region between the limits is set to zero.
Usage single region: {[}lower region limit,upper region limit{]},
use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item[{bordercut}] \leavevmode{[}None or iterable (with two floats), optional{]}
cut spectra at the low and high wavelength limit. (Default) None
uses the limits of measurement

\item[{wave\_nm\_bin}] \leavevmode{[}None or float, optional{]}
rebins the original data into even intervals. If set to None the original data will be used.
If set to a width (e.g. 2nm), the wavelength axis will be divided into steps of this size
and the mean of all measurements in the interval is taken. The re\sphinxhyphen{}binning stops as soon as
the measured stepsize is wider than given here, then the original bins are used.
This function is particularly useful for spectrometer with non\sphinxhyphen{}linear dispersion,
like a prism in the infrared.

\item[{intensity\_range}] \leavevmode{[}None, float or list {[}of two floats{]}{]}
intensity\_range is a general switch that governs what intensity range the plots show.
For the 1d plots this is the y\sphinxhyphen{}axis for the 2d\sphinxhyphen{}plots this is the colour scale.
This parameter recognizes three settings. If set to “None” (Default) this uses the minimum and
maximum of the data. A single value like in the example below and the intended use is the symmetric
scale while a list with two entries an assymmetric scale e.g.
intensity\_range=3e\sphinxhyphen{}3 is converted into intensity\_range={[}\sphinxhyphen{}3e\sphinxhyphen{}3,3e\sphinxhyphen{}3{]}

\item[{baseunit}] \leavevmode{[}str{]}
baseunit is a neat way to change the unit on the time axis of the plots. (Default) ‘ps’, but they
can be frames or something similarly. This is changing only the label of the axis.
During the import there is the option to divide the numbers by a factor.
I have also used frames or fs as units. Important is that all time units will be labeled with
this unit.

\item[{f}] \leavevmode{[}str{]}
f is a replacement title that is set instead of the title. mainly used to have some options
(Default) is ‘standard’

\item[{log\_fit}] \leavevmode{[}bool, optional{]}
(default)= False Used for legend generation, tells if the fit was in log or lin space

\item[{mod}] \leavevmode{[}str, optional{]}
Used for legend generation, tells what model was used for fitting

\item[{cmap}] \leavevmode{[}None or matplotlib color map, optional{]}
is a powerfull variable that chooses the colour map applied for all plots. If set to
None (Default) then the self.cmap is used.
As standard I use the color map “jet” from matplotlib. There are a variety of colormaps
available that are very usefull. Beside “jet”, “viridis” is a good choice as it is well
visible under red\sphinxhyphen{}green blindness. Other useful maps are “prism” for high fluctuations
or diverging color maps like “seismic”.
See \sphinxurl{https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html} for a comprehensive
selection. In the code the colormaps are imported so if plot\_func is imported as pf then
self.cmap=pf.cm.viridis sets viridis as the map to use. Internally the colors are chosen
with the “colm” function. The 2d plots require a continuous color map so if something
else is give 2d plots are shown automatically with “jet”. For all of the 1d plots however
I first select a number of colors before each plot. If cmap is a continous map then these
are sampled evenly over the colourmap. Manual iterables of colours
cmap={[}(1,0,0),(0,1,0),(0,0,1),…{]} are also accepted, as are vectors or dataframes that
contain as rows the colors. There must be of course sufficient colors present for
the numbers of lines that will be plotted. So I recommend to provide at least 10 colours
(e.g.\textasciitilde{}your university colors). colours are always given as a, list or tuple with RGA or RGBA
(with the last A beeing the Alpha=transparency. All numbers are between 0 and 1.
If a list/vector/DataFrame is given for the colours they will be used in the order provided.

\item[{print\_click\_position}] \leavevmode{[}bool, optional{]}
if True then the click position is printed for the spectral plots

\end{description}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ta}\PYG{o}{.}\PYG{n}{plot\PYGZus{}fit\PYGZus{}output}\PYG{p}{(}\PYG{n}{ta}\PYG{o}{.}\PYG{n}{re}\PYG{p}{,}\PYG{n}{ta}\PYG{o}{.}\PYG{n}{ds}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{plot\_raw() (in module plot\_func)@\spxentry{plot\_raw()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.plot_raw}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{plot\_raw}}}{\emph{\DUrole{n}{ds}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{plotting}\DUrole{o}{=}\DUrole{default_value}{range(0, 4)}}, \emph{\DUrole{n}{title}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{intensity\_range}\DUrole{o}{=}\DUrole{default_value}{0.01}}, \emph{\DUrole{n}{baseunit}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}ps\textquotesingle{}}}, \emph{\DUrole{n}{timelimits}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{scattercut}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{bordercut}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{wave\_nm\_bin}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{width}\DUrole{o}{=}\DUrole{default_value}{10}}, \emph{\DUrole{n}{rel\_wave}\DUrole{o}{=}\DUrole{default_value}{array({[}400, 500, 600, 700, 800{]})}}, \emph{\DUrole{n}{rel\_time}\DUrole{o}{=}\DUrole{default_value}{{[}1, 5, 10{]}}}, \emph{\DUrole{n}{time\_width\_percent}\DUrole{o}{=}\DUrole{default_value}{10}}, \emph{\DUrole{n}{ignore\_time\_region}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{time\_bin}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{cmap}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{color\_offset}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{log\_scale}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{plot\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}symlog\textquotesingle{}}}, \emph{\DUrole{n}{lintresh}\DUrole{o}{=}\DUrole{default_value}{0.3}}, \emph{\DUrole{n}{times}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{save\_figures\_to\_folder}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{savetype}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}png\textquotesingle{}}}, \emph{\DUrole{n}{path}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{filename}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{print\_click\_position}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{data\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}differential Absorption in \$\textbackslash{}\textbackslash{}mathregular\{\textbackslash{}\textbackslash{}Delta OD\}\$\textquotesingle{}}}, \emph{\DUrole{n}{plot\_second\_as\_energy}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{units}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}nm\textquotesingle{}}}}{}
This is the extended plot function, for convenient object based plotting see TA.Plot\_RAW
This function plotts of various RAW (non fitted) plots. Based on the DataFrame ds a number of
cuts are created using the shaping parameters explained below.
In all plots the RAW data is plotted as dots and interpolated with lines
(using Savitzky\sphinxhyphen{}Golay window=5, order=3 interpolation).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ds}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}) \textendash{} This dataframe contains the data to be plotted. It is copied and sliced into the
regions defined. The dataframe expects the time to be in Index and the wavelength/energy
to be in the columns. The spectra is plotted with a second (energy) axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plotting}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of integers}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} 
This parameter determines which figures are plotted
the figures can be called separately with plotting = 1
or with a list of plots (Default) e.g.plotting=range(4) calls plots 0,1,2,3
The plots have the following numbers:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{-1}
\item {} 
Matrix

\item {} 
Kinetics

\item {} 
Spectra

\item {} 
SVD

\end{enumerate}


\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} title to be used on top of each plot
The (Default) None triggers  self.filename to be used. Setting a specific title as string will
be used in all plots. To remove the title all together set an empty string with this command title=””

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{intensity\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{of two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} intensity\_range is a general switch that governs what intensity range the plots show.
For the 1d plots this is the y\sphinxhyphen{}axis for the 2d\sphinxhyphen{}plots this is the colour scale.
This parameter recognizes three settings. If set to “None” (Default) this uses the minimum and
maximum of the data. A single value like in the example below and the intended use is the symmetric
scale while a list with two entries an assymmetric scale e.g.
intensity\_range=3e\sphinxhyphen{}3 is converted into intensity\_range={[}\sphinxhyphen{}3e\sphinxhyphen{}3,3e\sphinxhyphen{}3{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} this is the datatype and effectively the unit put on the intensity axis
(Default)’differential Absorption in \$mathregular\{Delta OD\}\$

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{baseunit}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} baseunit is a neat way to change the unit on the time axis of the plots. (Default) “ps”, but they
can be frames or something similarly. This is changing only the label of the axis.
During the import there is the option to divide the numbers by a factor.
I have also used frames or fs as units. Important is that all time units will be labeled with
this unit.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{timelimits}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of 2 floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut times at the low and high time limit. (Default) None uses the limits of measurement
Important: If either the background or the chirp is to be fit this must include the
time before zero! Useful: It is useful to work on different regions, starting with
the longest (then use the ta.Backgound function prior to fit) and expand from there

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scattercut}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{other iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{always pairs!}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} intented to “cut” one or multiple scatter regions. (if (Default) None nothing
happens) If it is set the spectral region between the limits is set to zero.
Usage single region: {[}lower region limit,upper region limit{]},
use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bordercut}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{with two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut spectra at the low and high wavelength limit. (Default) None
uses the limits of measurement

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wave\_nm\_bin}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} rebins the original data into even intervals. If set to None the original data will be used.
If set to a width (e.g. 2nm), the wavelength axis will be divided into steps of this size
and the mean of all measurements in the interval is taken. The re\sphinxhyphen{}binning stops as soon as
the measured stepsize is wider than given here, then the original bins are used.
This function is particularly useful for spectrometer with non\sphinxhyphen{}linear dispersion,
like a prism in the infrared.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{width}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the width used in kinetics, see below (Default) 10nm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rel\_wave}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} “rel\_wave” and “width” (in the object called “wavelength\_bin” work together for the creation
of kinetic plots. When plotting kinetic spectra one line will be plotted for each entrance
in the list/vector rel\_wave. During object generation the vector np.arange(300,1000,100)
is set as standard. Another typical using style would be to define a list of interesting
wavelength at which a kinetic development is to be plotted. At each selected wavelength
the data between wavelength+ta.wavelength\_bin and wavelength\sphinxhyphen{}ta.wavelength\_bin is averaged
for each timepoint returned

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rel\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list/vector}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} For each entry in rel\_time a spectrum is plotted. If time\_width\_percent=0 (Default) the
nearest measured timepoint is chosen. For other values see “time\_width\_percent”

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time\_width\_percent}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} “rel\_time” and “time\_width\_percent” work together for creating spectral plots at
specific timepoints. For each entry in rel\_time a spectrum is plotted.
If however e.g. time\_width\_percent=10 the region between the timepoint closest
to the  1.1 x timepoint and 0.9 x timepoint is averaged and shown
(and the legend adjusted accordingly). This is particularly useful for the densly
sampled region close to t=0. Typically for a logarithmic recorded kinetics, the
timepoints at later times will be further appart than 10 percent of the value,
but this allows to elegantly combine values around time=0 for better statistics.
This averaging is only applied for the plotting function and not for the fits.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ignore\_time\_region}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{of lists}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut set a time range with a low and high limit from the fits. (Default) None nothing happens
The region will be removed during the fitting process (and will be missing in the fit\sphinxhyphen{}result
plots)
Usage single region: {[}lower region limit,upper region limit{]},
use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time\_bin}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is dividing the points on the time\sphinxhyphen{}axis in even bins and averages the found values in between.
This is a hard approach that also affects the fits. I do recommend to use this carefully,
it is most useful for modulated data. A better choice for transient absorption that only
affects the kinetics is “time\_width\_percent”

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib color map}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is a powerfull variable that chooses the colour map applied for all plots. If set to
None (Default) then the self.cmap is used.
As standard I use the color map “jet” from matplotlib. There are a variety of colormaps
available that are very usefull. Beside “jet”, “viridis” is a good choice as it is well
visible under red\sphinxhyphen{}green blindness. Other useful maps are “prism” for high fluctuations
or diverging color maps like “seismic”.
See \sphinxurl{https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html} for a comprehensive
selection. In the code the colormaps are imported so if plot\_func is imported as pf then
self.cmap=pf.cm.viridis sets viridis as the map to use. Internally the colors are chosen
with the “colm” function. The 2d plots require a continuous color map so if something
else is give 2d plots are shown automatically with “jet”. For all of the 1d plots however
I first select a number of colors before each plot. If cmap is a continous map then these
are sampled evenly over the colourmap. Manual iterables of colours
cmap={[}(1,0,0),(0,1,0),(0,0,1),…{]} are also accepted, as are vectors or dataframes that
contain as rows the colors. There must be of course sufficient colors present for
the numbers of lines that will be plotted. So I recommend to provide at least 10 colours
(e.g. your university colors). colours are always given as a, list or tuple with RGA or RGBA
(with the last A beeing the Alpha=transparency. All numbers are between 0 and 1.
If a list/vector/DataFrame is given for the colours they will be used in the order provided.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{color\_offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} At the (Default) 0 the colours are chose from the beginning, for a larger value Color\_offset
colors are skipped. Usually only used if multiple plots are created, and the data/or fit is
only shown for some of them.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{log\_scale}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} If True (Default), The 2D plots (Matrix) is plotted with a pseudo logarithmic intensity scale.
This usually does not give good results unless the intensity scale is symmetric

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Scale\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} is a general setting that can influences what time axis will be used for the plots.
“symlog” (linear around zero and logarithmic otherwise) “lin” and “log” are valid options.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lintresh}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The pseudo logratihmic range “symlog” is used for most time axis. Symlog plots a range around
time zero linear and beyond this linear treshold ‘lintresh’ on a logarithmic scale. (Default) 0.3

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{times}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} are the number of components to be used in the SVD (Default) is None (which is seen as 6)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{save\_figures\_to\_folder}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} (Default) is False, if True the Figures are automatically saved

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{savetype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of str}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} matplotlib allows the saving of figures in various formats. (Default) “png”,
typical and recommendable options are “svg” and “pdf”.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{path object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} This defines where the files are saved if the safe\_figures\_to\_folder parameter is True,
quite useful if a lot of data sets are to be printed fast.
If a path is given, this is used. If a string like the (Default) “result\_figures” is given,
then a subfolder of this name will be used (an generated if necessary)
relative to self.path. Use and empty string to use the self.path
If set to None, the location of the plot\_func will be used and
a subfolder with title “result\_figures” be generated here

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} offers to replace the base\sphinxhyphen{}name used for all plots (to e.g.\textasciitilde{}specify what sample was used).
if (Default) None is used, the self.filename is used as a base name. The filename plays only a
role during saving, as does the path and savetype

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{print\_click\_position}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if True then the click position is printed for the spectral plots

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_time() (in module plot\_func)@\spxentry{plot\_time()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.plot_time}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{plot\_time}}}{\emph{ds}, \emph{ax=None}, \emph{rel\_time=None}, \emph{time\_width\_percent=10}, \emph{ignore\_time\_region=None}, \emph{wave\_nm\_bin=None}, \emph{title=None}, \emph{text\_in\_legend=None}, \emph{baseunit=\textquotesingle{}ps\textquotesingle{}}, \emph{lines\_are=\textquotesingle{}smoothed\textquotesingle{}}, \emph{scattercut=None}, \emph{bordercut=None}, \emph{subplot=False}, \emph{linewidth=1}, \emph{color\_offset=0}, \emph{intensity\_range=None}, \emph{plot\_second\_as\_energy=True}, \emph{cmap=\textless{}matplotlib.colors.ListedColormap object\textgreater{}}, \emph{data\_type=\textquotesingle{}differential Absorption in \$\textbackslash{}\textbackslash{}mathregular\{\textbackslash{}\textbackslash{}Delta OD\}\$\textquotesingle{}}, \emph{units=\textquotesingle{}nm\textquotesingle{}}}{}~\begin{description}
\item[{Function to create plots at a certain time. In general you give under rel\_time a}] \leavevmode
list of times at which yu do want to plot the time width percentage means that
this function integrates ewverything plus minus 10\% at this time. lines\_are is a
switch that regulates what is plotted. data plots the data only,
smoothed plots the data and a smoothed version of the data, fitted plots only the fit.
the subplot switch is for using this to plot e.g. multiple different datasets.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ds}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataFrame}}) \textendash{} This dataframe contains the data to be plotted. It is copied and sliced into the
regions defined. The dataframe expects the time to be in Index and the wavelength/energy
to be in the columns. The spectra is plotted with a second (energy) axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib axis object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if None (Default), a figure and axis will be generated for the plot, if axis is given the plot will
placed in there.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} this is the datatype and effectively the unit put on the intensity axis
(Default)’differential Absorption in \$mathregular\{Delta OD\}\$

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rel\_time}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list/vector}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} For each entry in rel\_time a spectrum is plotted. If time\_width\_percent=0 (Default) the
nearest measured timepoint is chosen. For other values see ‘time\_width\_percent’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{time\_width\_percent}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} “rel\_time” and “time\_width\_percent” work together for creating spectral plots at
specific timepoints. For each entry in rel\_time a spectrum is plotted.
If however e.g. time\_width\_percent=10 the region between the timepoint closest
to the  1.1 x timepoint and 0.9 x timepoint is averaged and shown
(and the legend adjusted accordingly). This is particularly useful for the densly
sampled region close to t=0. Typically for a logarithmic recorded kinetics, the
timepoints at later times will be further appart than 10 percent of the value,
but this allows to elegantly combine values around time=0 for better statistics.
This averaging is only applied for the plotting function and not for the fits.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ignore\_time\_region}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{of lists}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut set a time range with a low and high limit from the fits. (Default) None nothing happens
The region will be removed during the fitting process (and will be missing in the fit\sphinxhyphen{}result
plots)
Usage single region: {[}lower region limit,upper region limit{]},
use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wave\_nm\_bin}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} rebins the original data into even intervals. If set to None the original data will be used.
If set to a width (e.g. 2nm), the wavelength axis will be divided into steps of this size
and the mean of all measurements in the interval is taken. The re\sphinxhyphen{}binning stops as soon as
the measured stepsize is wider than given here, then the original bins are used.
This function is particularly useful for spectrometer with non\sphinxhyphen{}linear dispersion,
like a prism in the infrared.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{title}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} title to be used on top of each plot
The (Default) None triggers  self.filename to be used. Setting a specific title as string will
be used in all plots. To remove the title all together set an empty string with this command title=””

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{linewidth}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} linewidth to be used for plotting

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{text\_in\_legend}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} text to be used in legend before the actually lines and colours (set as heasder)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{baseunit}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} baseunit is a neat way to change the unit on the time axis of the plots. (Default) ‘ps’, but they
can be frames or something similarly. This is changing only the label of the axis.
During the import there is the option to divide the numbers by a factor.
I have also used frames or fs as units. Important is that all time units will be labeled with
this unit.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{scattercut}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{other iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{always pairs!}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} intented to “cut” one or multiple scatter regions. (if (Default) None nothing
happens) If it is set the spectral region between the limits is set to zero.
Usage single region: {[}lower region limit,upper region limit{]},
use for multiple regions:{[}{[}lower limit 1,upper limit 1{]},{[}lower limit 2,upper limit 2{]},…{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bordercut}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{with two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} cut spectra at the low and high wavelength limit. (Default) None
uses the limits of measurement

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{; bool}} (\sphinxstyleliteralemphasis{\sphinxupquote{subplot}}) \textendash{} False (Default) means this is a main plot in this axis! if True then this is the second plot in the axis
and things like axis ticks should not be reset
this also avoids adding the object to the legend

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{optional}} \textendash{} False (Default) means this is a main plot in this axis! if True then this is the second plot in the axis
and things like axis ticks should not be reset
this also avoids adding the object to the legend

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{color\_offset}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} At the (Default) 0 the colours are chose from the beginning, for a larger value Color\_offset
colors are skipped. Usually only used if multiple plots are created, and the data/or fit is
only shown for some of them.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{intensity\_range}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{of two floats}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} intensity\_range is a general switch that governs what intensity range the plots show.
For the 1d plots this is the y\sphinxhyphen{}axis for the 2d\sphinxhyphen{}plots this is the colour scale.
This parameter recognizes three settings. If set to “None” (Default) this uses the minimum and
maximum of the data. A single value like in the example below and the intended use is the symmetric
scale while a list with two entries an assymmetric scale e.g.
intensity\_range=3e\sphinxhyphen{}3 is converted into intensity\_range={[}\sphinxhyphen{}3e\sphinxhyphen{}3,3e\sphinxhyphen{}3{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plot\_second\_as\_energy}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} For (Default) True a second x\sphinxhyphen{}axis is plotted  with “eV” as unit

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cmap}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{matplotlib color map}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} is a powerfull variable that chooses the colour map applied for all plots. If set to
None (Default) then the self.cmap is used.
As standard I use the color map “jet” from matplotlib. There are a variety of colormaps
available that are very usefull. Beside “jet”, “viridis” is a good choice as it is well
visible under red\sphinxhyphen{}green blindness. Other useful maps are “prism” for high fluctuations
or diverging color maps like “seismic”.
See \sphinxurl{https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html} for a comprehensive
selection. In the code the colormaps are imported so if plot\_func is imported as pf then
self.cmap=pf.cm.viridis sets viridis as the map to use. Internally the colors are chosen
with the “colm” function. The 2d plots require a continuous color map so if something
else is give 2d plots are shown automatically with “jet”. For all of the 1d plots however
I first select a number of colors before each plot. If cmap is a continous map then these
are sampled evenly over the colourmap. Manual iterables of colours
cmap={[}(1,0,0),(0,1,0),(0,0,1),…{]} are also accepted, as are vectors or dataframes that
contain as rows the colors. There must be of course sufficient colors present for
the numbers of lines that will be plotted. So I recommend to provide at least 10 colours
(e.g.\textasciitilde{}your university colors). colours are always given as a, list or tuple with RGA or RGBA
(with the last A beeing the Alpha=transparency. All numbers are between 0 and 1.
If a list/vector/DataFrame is given for the colours they will be used in the order provided.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{s2\_vs\_smin2() (in module plot\_func)@\spxentry{s2\_vs\_smin2()}\spxextra{in module plot\_func}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot_func:plot_func.s2_vs_smin2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot\_func.}}\sphinxbfcode{\sphinxupquote{s2\_vs\_smin2}}}{\emph{\DUrole{n}{Spectral\_points}\DUrole{o}{=}\DUrole{default_value}{512}}, \emph{\DUrole{n}{Time\_points}\DUrole{o}{=}\DUrole{default_value}{130}}, \emph{\DUrole{n}{number\_of\_species}\DUrole{o}{=}\DUrole{default_value}{3}}, \emph{\DUrole{n}{fitted\_kinetic\_pars}\DUrole{o}{=}\DUrole{default_value}{7}}, \emph{\DUrole{n}{target\_quality}\DUrole{o}{=}\DUrole{default_value}{0.95}}}{}
dfn is numerator and number of fitted parameters, dfd is denominator and number of degrees of freedom,
F\sphinxhyphen{}test is deciding if a set of parameters gives a statistical significant difference. T\sphinxhyphen{}test is if a single parameter gives      statistical difference.
Null hypothesis, all parameter are zero, if significant, the coefficients improve the fit
the f\sphinxhyphen{}statistics compares the number of
“fitted parameter”=number of species*number of spectral points + number of kinetic parameter
“free points”=number of species*number of spectral points*number of time points \sphinxhyphen{} fitted parameter
within the target quality, meaning, what fraction do my variances need to have, so that I’m 100\% * target\_quality sure that they are different from zero

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{p}
\item\relax\sphinxstyleindexentry{plot\_func}\sphinxstyleindexpageref{plot_func:\detokenize{module-plot_func}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
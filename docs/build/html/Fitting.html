

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Fitting, Parameter optimization and Error estimation &mdash; KiMoPack 6.5.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Comparative plotting" href="Comparing.html" />
    <link rel="prev" title="Plotting functions" href="Plotting.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> KiMoPack
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Main_tasks.html">Main Tasks overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="Opening.html">Opening of data</a></li>
<li class="toctree-l1"><a class="reference internal" href="Shaping.html">Shaping of Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="Plotting.html">Plotting functions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Fitting, Parameter optimization and Error estimation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#description-of-models">Description of models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#internal-kinetic-models">internal kinetic models</a></li>
<li class="toctree-l3"><a class="reference internal" href="#external-kinetic-models-as-defined-in-example-file-plot-func-function-library-py">external kinetic models as defined in example file “plot_func_function_library.py”</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#setting-of-fit-parameter">Setting of Fit parameter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#storing-of-fit-results">storing of fit results</a></li>
<li class="toctree-l2"><a class="reference internal" href="#trigger-the-fit">Trigger the Fit</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fitting-multiple-measured-files-at-once">Fitting multiple measured files at once</a></li>
<li class="toctree-l2"><a class="reference internal" href="#error-estimation">Error Estimation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iterative-fitting">Iterative Fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#species-spectral-development">Species Spectral Development</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Comparing.html">Comparative plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="Saving.html">Data Export and Project Saving</a></li>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Function Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="plot_func.html">KiMoPack - Functions</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">KiMoPack</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Fitting, Parameter optimization and Error estimation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/Fitting.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="fitting-parameter-optimization-and-error-estimation">
<h1>Fitting, Parameter optimization and Error estimation<a class="headerlink" href="#fitting-parameter-optimization-and-error-estimation" title="Permalink to this headline">¶</a></h1>
<p>Fitting data:                           <a class="reference internal" href="plot_func.html#plot_func.TA.Fit_Global" title="plot_func.TA.Fit_Global"><code class="xref py py-meth docutils literal notranslate"><span class="pre">self.Fit_Global()</span></code></a></p>
<p>One of the main functions of this program is to perform Global analysis
of one or multiple datasets. The fitting function is in its current
implementation embedded in the TA object and uses the parameter control
options of an lmfit parameter object as an essential tool. (my thanks to Matthew
Newville and colleagues for creating this phantastic tool) [M. Newville,
T. Stensitzki, D. B. Allen, A. Ingargiola, 2014. DOI:
10.5281/ZENODO.11813.]. To excecute an Optimization/Fit these essential
steps have to be followed (assuming that “ta” is your object):</p>
<dl class="simple">
<dt>Model</dt><dd><p>you have to define a model by setting ta.mod=”internal model name”
for one of the internal models, of by setting
ta.mod=external_function to an external function. For the internal
models three standards are implemented: “exponential”, “consecutive”
and “full_consecutive”. (see below). The external function will
receive a vector named “times” and parameter pandas.DataFrame named
“pardf”. It is expected to return a DataFrame with the times as index
and in the columns an expression of the relative concentrations. The
external function can reload whatever data is desired. The names of the
columns are used in all plots and reports. (see below a description
of the example functions defined in “plot_func_function_library.py”)</p>
</dd>
<dt>Parameter</dt><dd><p>For handling of Parameters I am using the lmfit Parameter objects to
have a flexible and fast Parameter handling toolset. The general
steps are: create a Parameter object (or use an existing parameter
object) set starting values and (optional) limits, relative
expressions and vary = True (if the parameter is to be optimised) (see below
for more details</p>
</dd>
<dt>Trigger the fitting</dt><dd><p>To trigger the fitting the function ta.Fit_Global() is called. The
fitting function will display its results on the screen and write
them into the TA object. first it will create an parameter object
ta.par_fit that contains the optimum parameter and can be used later,
second it writes the result dictionary ta.re. In this dictionary it
adds a number of results and parameters that are useful (see below
for further details) A number of error catching routines are build in
the fitting software. However it does sometimes (rare) come to
crashes. Then please adjust the parameter and or read the error
message. Important to notice is that this is a refinement of
parameter using an algorithm. Limiting the region where parameter can
be and choosing good starting values is essential to obtain reliable
results. (see below)</p>
</dd>
</dl>
<p>The general Modelling/Fitting process happens with the same approach for
internal models as well as for externally provided functions. Other
fitting processes like the optimization of the arrival time correction
are discussed further down in this document.</p>
<ol class="arabic simple">
<li><p>First a copy of the Data-Matrix ta.ds is created with the shaping
parameters</p></li>
<li><p>Then a Matrix is created that represents the fractional population of
each species (or process in case of the paral model). This Matrix
contains one entry for each timepoint and represents the kinetic
model based upon the starting parameter. (see below for a description
of the models). This model formation can by done by using a build in
or a user supplied function. (handled in the function “pf.build_c”)</p></li>
<li><p>Then the process/species associated spectra for each of the species
is calculated using the linalg.lstsq algorithm from numpy
(<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html">https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html</a>)</p></li>
<li><p>From the convoluted calculated species concentrations and spectra a
calculated matrix is formed (handled in the function “pf.fill_int”)</p></li>
<li><p>The difference between calculated and measured spectra is calculated,
point-wise squared and summed together. (function “err_func”)</p></li>
<li><p>This difference is minimized by iterating 2-4 with changing
parameters using an optimization algorithm (generally nelder-mead
simplex)</p></li>
<li><p>Finally in a last run of 2-5 the final spectra are calculated (using
the “final” flag) and the optimized parameter, the matrixes
(“A”-measured, “AC” - calculated, “AE” - linear error), spectra
(always called DAS) the concentrations (called “c”) are written in
the dictionary “ta.re” together with a few representations and other
fit outputs. The optimized parameter are also written into ta.par_fit
(as an parameter object) that can be re-used as input into further
optimization steps.</p></li>
</ol>
<p>The choice to use lmfit parameters allows the flexible handling of
constraints and freezing/releasing of parameter. (see below). Additional
fitting options include the fitting of the parameter of the arrival time
correction, the use of advanced optimization algorithms, and the
possibility to fit multiple datasets together.</p>
<div class="section" id="description-of-models">
<h2>Description of models<a class="headerlink" href="#description-of-models" title="Permalink to this headline">¶</a></h2>
<div class="section" id="internal-kinetic-models">
<h3>internal kinetic models<a class="headerlink" href="#internal-kinetic-models" title="Permalink to this headline">¶</a></h3>
<p>The internal kinetic models are created to be highly flexible. The
program recognizes all parameter that are “rates” by recognizing the
names with “k” followed by one or multiple digits. The program starts at
“k0” and then uses “k1”,”k2”,… in an un-interrupted series. If one key
is missing the program stops searching for more. However that offers the
fast and easy possibility to add additional components to the fit by
adding new parameters with an increasing number. All rates are to be
given as rates and are assumed to be in the same units as is the
measured matrix. So if the measured data is in picoseconds, the rates
are in <span class="math notranslate nohighlight">\(ps^-1\)</span>. See section <a class="reference internal" href="Shaping.html#data-shaping-settings-that-affect-the-fits"><span class="std std-ref">Data shaping settings that affect the fits</span></a>
for more information.</p>
<p><strong>ta.mod=”exponential”</strong> In this model the data is represented by
independent exponential decays. For each component the a symmetric
response function is formed (error function) using the the parameter
“resolution” as characteristic width (corresponding to 2 x
<span class="math notranslate nohighlight">\(\sigma\)</span>) with with “t0” as the point of 50<span class="math notranslate nohighlight">\(\%\)</span> rise from
0. At the time 1 x resolution the signal is 97.8<span class="math notranslate nohighlight">\(\%\)</span>. This rise
is convoluted with an exponential decay function per given decay
constant. The integral signal of the error function is 1, to which all
the decays are set (assuming that they do not decay faster than 2x
resolution) The extracted Spectra are commonly called decay associated
spectra (DAS). Their relative intensity is corresponding with the
exponential pre-factors for single exponential fits to the data (for
each wavelength). Additional parameter that can be set are “background”
(assuming a species that is constantly “1”) and “infinite” a species
that is rising with the response function and then constant “1”.</p>
<p><strong>ta.mod=”consecutive”</strong> This fit assumes a model of consecutive
exponential decays. A response function with “t0” = 50<span class="math notranslate nohighlight">\(\%\)</span> rise
is formed that rises symmetric to <span class="math notranslate nohighlight">\(2\sigma \approx 98\%\)</span> (of 1) at
1 x the parameter “resolution” followed by A-&gt;B-&gt;C consecutive decay.
This particular model uses a preudo approach to this fit to speed up the
calculations. The parameter are optimised by modelling an “exponential”
model (see above) followed by a single step of a “true consecutive”
decay (see below). This approach is quite representative unless there
are fast components of the order of the response function involved in
the process and the different processes are clearly separated (each rate
one of magnitude separated). Additional parameter that can be set are
“background” (assuming a species that is constantly “1”) and “infinite”
a species that is with the last decay constant to a constant “1” and not
decaying.</p>
<p><strong>ta.mod=”full_consecutive”</strong> This fit assumes a model of consecutive
exponential decays. A response function with “t0” = 50<span class="math notranslate nohighlight">\(\%\)</span> rise
is formed that rises to <span class="math notranslate nohighlight">\(2\sigma \approx 98\%\)</span> (of 1), at 1x the
parameter “resolution” followed by A-&gt;B-&gt;C consecutive decay. This model
is formed by a stepwise integrated differential equation and represents
the “true” sequential model. The “rise” is simulated by sampleing a true
gaussian function and adding the appropiate fraction to the excited
state. Arbitrary pulse/response shapes can be sampled in the advanced
functions. Additional parameter that can be set are “background”
(assuming a species that is constantly “1”) and “infinite” a species
that is with the last decay constant to a constant “1” and not decaying.</p>
</div>
<div class="section" id="external-kinetic-models-as-defined-in-example-file-plot-func-function-library-py">
<h3>external kinetic models as defined in example file “plot_func_function_library.py”<a class="headerlink" href="#external-kinetic-models-as-defined-in-example-file-plot-func-function-library-py" title="Permalink to this headline">¶</a></h3>
<p>External model functions can be written and used to create the matrix of
populations. The external function will receive a vector named “times”
and a pandas.DataFrame with the columne “value” named “pardf”. It is
expected to return a DataFrame with the times as index and in the
columns the an expression of the relative concentrations. The parameters
have a name and a float value. The external function can however load
whatever other data is required. We have for example modelled
spectro-electro-chemistry data by reading the current from cyclic
voltametry and using the value to extract a number representing the
concentration of a certain species. An important feature of external
functions are that columns in the DataFrame can be labeled with names.
These names will be used in the plots and significantly improve the work
with complex models. The parameter that are given to the functions can
be name arbitrarily but must match:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="n">z_</span><span class="p">][</span><span class="n">a</span><span class="o">-</span><span class="n">z</span> <span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="n">_</span><span class="p">]</span><span class="o">*</span>
</pre></div>
</div>
<p>meaning, it must start with a letter and can only contain (small) letters,
numbers and “_”. Important is that in order allow for some of the parameter
settings (see section :ref:’Setting of Fit parameter’) if the first
letter is a “k” and the second string is a number the parameter will be
interpreted as a rate. (recognition is done by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>bool(re.match(re.compile(’[k]&#39;̣), parameter_name[:2])
</pre></div>
</div>
<p>In the file “plot_func_function_library.py” we provide a number of
useful example functions that show how to model a variety of different
cases. In general there is no restriction to what type of function can
be modelled here, but all these examples are based upon transient
absorptions spectroscopy. In these examples we model the instrument
response by a gaussian pulse. In general, any pulse shape could be
loaded from an external file. In these examples we sample the
differential change of a concentration by writing the differential for
the dynamics. The excitation is then represented by sampling the
gaussian pulse and “raising” a certain fraction of the molecules into
the excited state. As the gaussian used here is normalized to have the
integral of “1”, the total initial concentration is “1” and the numbers
in this matrix representative with a “fractional population”. Each step
in the code is documented and the code can be adapted easily to a wide
variety of problems. The example functions provided are</p>
<blockquote>
<div><ul class="simple">
<li><p><strong>manual_consecutative</strong>
An example how a stepwise consecutative decay would look like.</p></li>
<li><p><strong>Square_dependence</strong>
An example in which the pumping “pulse” is scaled by a parameter and
a non linear decay is included (e.g. recombination)</p></li>
<li><p><strong>gaussian_distribution</strong>
A model where a substance is excited into a state, followed by a
linear decays step into a state that decays with a distribution of
rates (here assumed gaussian) into a final, non decaying state. These
type of complex decays are often observed in protein folding</p></li>
</ul>
</div></blockquote>
<p><strong>Usage of external functions:</strong> To use an external function, this
function needs to be handed to ta.mod. For an external function this
means that it has to be imported, and then handed to ta.mod. In the
example below we import an external module (the file
“plot_func_function_library.py”) as “func” and then use from this
external module the function “Square_dependence”.
All the models are extensively documented in the function library. These
functions can load any external file with additional information. It is
highly recommended to use the versatile parameter setting (see below)
to adjust models. E.g. can a certain kinetic pathway be disabled by
setting its rate to “0” and using the option “vary=False” to lock it.
(see below in the parameter section).</p>
<p>It is highly recommended to use the docstring (description) directly
below the definition of the model to describe what it does. This string
is stored with ta.Save_Project and should be sufficient to identify the
model. Also if all the species are labeled (label the columns of the
returning DataFrame) These names are used throughout the plotting
functions. (please see examples for more explanation)</p>
<p>Remark: Importing an external function happens in python only if it has
not already been imported. So if the fitting function is adapted, either
the whole notebook/console needs to be restart, or (better) the function
should be reloaded. I recommend to use the function “reload” from the
“importlib” for this purpose (see the example below) This should happen
before the function is handed to ta.mod (as shown in the workflow
notebook).</p>
</div>
</div>
<div class="section" id="setting-of-fit-parameter">
<h2>Setting of Fit parameter<a class="headerlink" href="#setting-of-fit-parameter" title="Permalink to this headline">¶</a></h2>
<p>The fit parameter are a crucial point for achieving meaningful results
from an optimization. In general three different types need to be
chosen, first the model (see ) then if the rate parameter (necessarily
call k0, k1, k2, ..) will be handed into the fitting function as they
are or in log space. (ta.log_fit) and finally the parameter themselves.
The <strong>log_fit</strong> option can be important as it brings widely separated
rats into the very similar numerical range, simplifying the function of
the simplex optimizer. In this program all rates are limited to be above
0 independent if they are handled linearly or in log. This happens in
the begin of the fit function, here all “rates” are identified that have
the name “ki” with i =0-99 and then their lower limit is set to zero
(unless they have already a lower limit &gt;0).</p>
<p>The parameter are handled as a lmfit Parameter object. Inside the
fitting function this object is converted into a pandas Dataframe that
is handed to the function generating the time dependent
“concentrations”.</p>
<blockquote>
<div><ul>
<li><p>initialize
The lmfit parameter object needs to be initialized with
“ta.par=lmfit.Parameters()”. In the fitting function I convert the
parameter object into a DataFrame and back on several places. A
function par_to_pardf and pardf_to_par does this conversion. All the
parameter set are available through the ta.par object and can thus be
given to other fits. After the fit there is a new object calles
ta.par_fit that contains the optimized fit results. So if you would
like to re-use the old results ta.par=ta.par_fit accomplishes this.</p></li>
<li><p>add parameter
Each parameter must
have a name from:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">a</span><span class="o">-</span><span class="n">z_</span><span class="p">][</span><span class="n">a</span><span class="o">-</span><span class="n">z0</span><span class="o">-</span><span class="mi">9</span><span class="n">_</span><span class="p">]</span>\<span class="o">*</span>
</pre></div>
</div>
<p>(starting with a letter and then
letters and stars and “_”). In the included models (see
:ref:’Description of models’) parameters like “background”
and “infinite” trigger the inclusion of e.g. the background or a non
decaying component. Other parameters should be initiated with a value
that has to be of type float (number). Important to not is that the
code automatically recognizes parameter that have the name “ki” with
i and element of 0-99 as a rate. These rates are brought in and out
of logspace with the switch “log_fit”. All other names can be freely
chosen. I highly recommend to do this for the sake of structure. e.g.
a “threshold” could be named as such</p>
</li>
<li><p>add or set
New parameter are “added” to the parameter object. Existing
parameter can be “set” to a certain value. If Set is used any of
the additional/optional things can be set alone.</p></li>
<li><p>limits min and max
Optional is the settings of limits (<strong>min</strong> and <strong>max</strong>). If a limit
is set the parameter will stay within the limit, even if a starting
value outside the limit is given! Important to note is that after
each optimization that included limits the results should be checked
if the limits were reached. (the printed output states the limits).
Limits are very important for the more advanced optimizers like AMPGO
(see section :ref:trigger-the-fit. The parameter tunneling
uses these limits as guidelines.</p></li>
<li><p>Vary=True/False
Very useful is the option “vary=True/False”. This switch freezes the
parameter, or allows it to be optimized by the algorithm. In the
progress of an analysis one often freezes a parameter to develop a
stable model and releases this parameter later. Particular the
parameter “t0” which is in my models the starting point and
“resolution”, which is in my models the instrument response function
are parameter that are often frozen in the beginning. Fitting with
them enabled significantly extends the duration for finding a stable
fit. Often I first plot the function with the starting parameter,
temporarily setting all parameter to vary=False with the trick below,
to then step by step enable the optimization, while the starting
parameter are adapted.</p></li>
<li><p>expr
An advanced option is the setting of expressions. This are relations
to other parameter. e.g. expr=’k0’ sets the value of the current
parameter always the same as “k0”. The values are always given as
string so expr=’1-k0’ sets the value to 1 - the value of “k0”. Please
see the documentation of lmfit for further details</p></li>
</ul>
</div></blockquote>
<p>Very useful trick to set temporarily set all parameter to vary=False to
test e.g. starting conditions and then enable the optimization of a
single parameter. As here the “set” is used, the parameter can be
initially added with a different value. (see workflow notebook for
further examples).</p>
</div>
<div class="section" id="storing-of-fit-results">
<h2>storing of fit results<a class="headerlink" href="#storing-of-fit-results" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><p>ta.par
always contains the initial fit parameter (parameter object)</p></li>
<li><p>ta.par_fit
contains the fit results and can be directly re-used with
ta.par=ta.par_fit (parameter object)</p></li>
<li><p>ta.re[’fit_results_rates’]
contains the fit results in a neatly formated DataFrame in the form
of rates</p></li>
<li><p>ta.re[’fit_results_times’]
contains the fit results in a neatly formated DataFrame in the form
of decay times (1/rates)</p></li>
<li><p>ta.re[’fit_output’]
Is the results oject of the fit routine. It can be called and then
shows details like number of iterations, chi<span class="math notranslate nohighlight">\(^2\)</span>, fit
conditions and a lot more. This object is stored after a fit but is
NOT saved by ta.Save_Project!</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="trigger-the-fit">
<h2>Trigger the Fit<a class="headerlink" href="#trigger-the-fit" title="Permalink to this headline">¶</a></h2>
<p>The Fitting process is triggered by calling the function “Fit_Global”.
if the parameter were set as part of the object that contains this Fit
(as is usually the case with ta.par), than just calling the function
without any other parameters is a good choice. Internally the Fit
function is making a copy of the parameter and shapes the data, then it
optimized single or multiple datasets. As standard it uses the Nelder
Mead Simplex algorithm to minimize the error values defined by the
function pf.err_func and pf.err_func_multi. Currently the maximum
iterations are hard-coded to be max 10000. I have not needed more than
1000 for any well defined problem. The optimizer can be changes to
“Ampgo” that offers an advanced “tunneling” algorithm for checking for
global minima. Important for this to work properly all optimizing
parameter need “min” and “max” definitions. Parameter can additionally
be given via the parameter and module input at this stage, but in
general it is better to define them as part of the ta object. The
pf.err_func and pf.err_func_multi recognise if an internal or an
external fitting model is to be used by checking if “ta.mod” (or the
here given “mod”) are strings or something else (in which case it
assumes it is an external function). Additional modules from <a class="reference external" href="https://lmfit.github.io/lmfit-py/fitting.html">https://lmfit.github.io/lmfit-py/fitting.html</a>
can be easily implemented.</p>
<p>See section
<a class="reference internal" href="#external-kinetic-models-as-defined-in-example-file-plot-func-function-library-py"><span class="std std-ref">external kinetic models as defined in example file “plot_func_function_library.py”</span></a>
for examples how to define those. The fitting process is in all cases
the same. Advanced options include the use of fit_chirp that runs
multiple iterations of chirp fitting and global fitting iterative (to a
maximum of fit_chirp_iterations), or the multi_project module (see
below). In general the dump_paras can be used to write into the working
directory a file with the current fitting parameter and the optimum
achieved fitting parameter. This is intended for long and slow
optimizations to keep a record of the fits even if the fitting process
did not finish.</p>
<p><a class="reference internal" href="plot_func.html#plot_func.TA.Fit_Global" title="plot_func.TA.Fit_Global"><code class="xref py py-meth docutils literal notranslate"><span class="pre">self.Fit_Global()</span></code></a></p>
</div>
<div class="section" id="fitting-multiple-measured-files-at-once">
<h2>Fitting multiple measured files at once<a class="headerlink" href="#fitting-multiple-measured-files-at-once" title="Permalink to this headline">¶</a></h2>
<p>To fit multiple projects the fit function needs to get a number of
projects. These can of course be opened with a hand written loop. A
cleaner way is to either use the Gui function to open a list of
files. <a class="reference internal" href="Opening.html#opening-multiple-files"><span class="std std-ref">Opening multiple files</span></a>
As each file needs a chirp correction and these things I
recommend to use saved projects (hdf5 files) for this purpose. Please see
the function documentation for further details. In general this function is
fitting each of the projects separately, but using the same parameter. This means
that in general a new (different) DAS is calculated for each of the measurements.</p>
<p>To work with the same DAS for the measured and calculated matrices need to be
concatenated before the fitting. A convenient way to do this is to use the
shaped matrices (potentially with different scattercuts) and the concentrations
that are created after an individual fit:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># without scaling::</span>
</pre></div>
</div>
<blockquote>
<div><p>A_con=ta_list[0].re[‘A’]
c_con=ta_list[0].re[‘c’]</p>
</div></blockquote>
<p># With scaling:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_con</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">ta_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">re</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">],</span><span class="n">ta_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">re</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">0.5</span><span class="p">,</span><span class="n">ta_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">re</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">0.4</span><span class="p">])</span>
<span class="n">c_con</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">ta_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">re</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span><span class="n">ta_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">re</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span><span class="n">ta_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">re</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]])</span>
</pre></div>
</div>
<p># using the “fill_int” function calculates just the DAC:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">re</span><span class="o">=</span><span class="n">pf</span><span class="o">.</span><span class="n">fill_int</span><span class="p">(</span><span class="n">A_con</span><span class="p">,</span><span class="n">c_con</span><span class="p">,</span><span class="n">final</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively one could give this concatenated Matrix to the Fit_Global and construct
an assembled external function.</p>
</div>
<div class="section" id="error-estimation">
<h2>Error Estimation<a class="headerlink" href="#error-estimation" title="Permalink to this headline">¶</a></h2>
<p>Estimating errors correctly is based on estimating the validity of the full set of optimized parameter for this we use the F-statistics of the single or combined datasets to define a cutoff value. At the cutoff value the combined Chi^2 is so much larger than the minimum Chi^2 that this can not be explained statistically anymore. Practically this corresponds to making the “Null hypothesis” that all parameters are zero and if the difference of Chi^2 is statistically significant, the coefficients improve the fit
the f-statistics compares the number of
“fitted parameter”=number of species*number of spectral points + number of kinetic parameter
“free points”=number of datasets*number of spectral points*number of time points - fitted parameter
within the target quality, meaning, what fraction do my variances need to have, so that I’m 100% * target_quality sure that they are different from zero
This is done in the function <a class="reference internal" href="plot_func.html#plot_func.s2_vs_smin2" title="plot_func.s2_vs_smin2"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot_func.s2_vs_smin2()</span></code></a>. The confidence level then defines the cutoff value. For each (varied) parameter a separate optimization is performed, that attempts to find the upper and lower bound at which the total error of the re-optimized globally fitted results reaches the by F-statistics defined confidence bound. Careful, this option might run for very long time. Meaning that it typically takes 50 optimization per variable parameter (hard coded limit 200) The confidence level is to be understood that it defines the e.g. 0.65 * 100% area that the parameter with this set of values is within this bounds.</p>
</div>
<div class="section" id="iterative-fitting">
<h2>Iterative Fitting<a class="headerlink" href="#iterative-fitting" title="Permalink to this headline">¶</a></h2>
<p>as the fit results are written into the parameter ta.par_fit the fit can be very conveniently
triggered in an iterative fashion. This is particularly useful for refining the chirp.
The initially achieved optimal kinetic parameters are used as starting parameter for each
global fit after the chirp optimization. e.g. a 5 times iterative improvement can be achieved with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">start_error</span><span class="o">=</span><span class="n">ta</span><span class="o">.</span><span class="n">re</span><span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">]</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">par</span><span class="o">=</span><span class="n">ta</span><span class="o">.</span><span class="n">par_fit</span>
        <span class="n">ta</span><span class="o">.</span><span class="n">Fit_Global</span><span class="p">(</span><span class="n">fit_chirp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ta</span><span class="o">.</span><span class="n">re</span><span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">start_error</span><span class="p">:</span><span class="k">break</span>
</pre></div>
</div>
</div>
<div class="section" id="species-spectral-development">
<h2>Species Spectral Development<a class="headerlink" href="#species-spectral-development" title="Permalink to this headline">¶</a></h2>
<p>A small but often useful function is <a class="reference internal" href="plot_func.html#plot_func.Species_Spectra" title="plot_func.Species_Spectra"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pf.Species_Spectra()</span></code></a> It takes either a TA-Object or a concentration and spectral DataFrame and combines the concentration with the species associated spectrum. This leads to the matrix that is contributed by this specific species. As the concentration and the spectrum are combined, this represents the indeed measured signal. Here the ds-parameter of the Plot_RAW function offers a useful combination. assuming that we fitted: species 0,1,2, (or more) then:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#extract the spectra</span>
<span class="n">dicten</span><span class="o">=</span><span class="n">pf</span><span class="o">.</span><span class="n">Species_Spectra</span><span class="p">(</span><span class="n">ta</span><span class="p">)</span>
<span class="c1">#plot the measured spectrum and substract the</span>
<span class="c1">#contribution of &quot;1&quot; and &quot;2&quot;</span>
<span class="n">ta</span><span class="o">.</span><span class="n">Plot_RAW</span><span class="p">(</span><span class="n">ds</span><span class="o">=</span><span class="n">ta</span><span class="o">.</span><span class="n">re</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span><span class="o">-</span><span class="n">dicten</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">dicten</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="Comparing.html" class="btn btn-neutral float-right" title="Comparative plotting" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="Plotting.html" class="btn btn-neutral float-left" title="Plotting functions" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Jens Uhlig.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>